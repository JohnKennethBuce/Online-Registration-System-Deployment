
10/10/2025 


when I Logged in as the 2nd Registered superadmin, I created this using our usermanagement, but Logging in as Seeded 1st Superadmin is working just fine

ServerModeManager.jsx:29

POST http://127.0.0.1:8000/api/server-mode 403 (Forbidden)



Promise.thenhandleSetMode@ServerModeManager.jsx:29onClick@ServerModeManager.jsx:52

axios.js:35

🔒 Unauthorized or Forbidden. Logging out...

(anonymous)@axios.js:35Promise.thenhandleSetMode@ServerModeManager.jsx:29onClick@ServerModeManager.jsx:52 

Here's my Front end and Backend for those part  

C:\xampp\htdocs\Online-Registration-System\backend\app\Enums\Permission.php 

<?php

namespace App\Enums;

enum Permission: string
{
    // Dashboard Permissions
    case VIEW_DASHBOARD = 'view-dashboard';

    // Registration Permissions
    case VIEW_REGISTRATIONS = 'view-registrations';
    case CREATE_REGISTRATION = 'create-registration';
    case EDIT_REGISTRATION = 'edit-registration';
    case DELETE_REGISTRATION = 'delete-registration';

    // User Management Permissions
    case VIEW_USERS = 'view-users';
    case CREATE_USER = 'create-user';
    case EDIT_USER = 'edit-user';
    case DELETE_USER = 'delete-user';

    // Settings Permissions
    case VIEW_SETTINGS = 'view-settings';
    case EDIT_SETTINGS = 'edit-settings';

    // Server Mode Permissions
    case VIEW_SERVER_MODE = 'view-server-mode';
    case EDIT_SERVER_MODE = 'edit-server-mode';

    // Role Management Permissions
    case MANAGE_ROLES = 'manage-roles';

    /**
     * Helper function to get all permission values as an array.
     * Useful for seeding the database.
     */
    public static function all(): array
    {
        return array_column(self::cases(), 'value');
    }
}  

C:\xampp\htdocs\Online-Registration-System\backend\app\Http\Controllers\RoleController.php 

<?php

namespace App\Http\Controllers;

use App\Models\Role;
use Illuminate\Http\Request;
use App\Enums\Permission;

class RoleController extends Controller
{
    /**
     * List all editable roles.
     */
    public function index()
    {
        // We exclude the 'user' role as it has no system permissions to edit.
        $roles = Role::where('name', '!=', 'user')->get();
        return response()->json($roles);
    }

    /**
     * Update the permissions for a specific role.
     */
    public function update(Request $request, Role $role)
    {
        $validated = $request->validate([
            'permissions' => 'required|array',
            'permissions.*' => 'string', // Ensure all items in the array are strings
        ]);
        
        // This is a safeguard. It prevents the 'root' superadmin from accidentally
        // removing all permissions from the 'superadmin' role itself.
        if ($role->name === 'superadmin') {
            $validated['permissions'] = Permission::all();
        }

        $role->update(['permissions' => $validated['permissions']]);

        return response()->json($role);
    }

    /**
     * Provide a list of all available permissions from the Enum.
     */
    public function getAllPermissions()
    {
        return response()->json(Permission::all());
    }
} 

C:\xampp\htdocs\Online-Registration-System\backend\app\Http\Controllers\UserController.php 

<?php

namespace App\Http\Controllers;

use App\Models\User;
use App\Models\Role;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rule;
use Illuminate\Support\Facades\Auth;

class UserController extends Controller
{
    /**
     * List all users (excluding the superadmin role).
     */
    public function index()
    {
        $adminRole = Role::where('name', 'admin')->first();
        if (!$adminRole) {
            return response()->json(['users' => []]);
        }
        
        $users = User::where('role_id', $adminRole->id)->latest()->paginate(25);
        return response()->json($users);
    }

    /**
     * Create a new admin user.
     */
    public function store(Request $request)
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|email|max:255|unique:users',
            'password' => 'required|string|min:8',
            'role_id' => 'required|integer|exists:roles,id', // <-- Add validation for role_id
        ]);

        $user = User::create([
            'name' => $validated['name'],
            'email' => $validated['email'],
            'password' => $validated['password'],
            'role_id' => $validated['role_id'], // <-- Use the role_id from the request
            'created_by' => Auth::id(),
        ]);

        return response()->json($user, 201);
    }

    /**
     * Update a user's information.
     */
    public function update(Request $request, User $user)
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'email' => ['required', 'string', 'email', 'max:255', Rule::unique('users')->ignore($user->id)],
            'password' => 'nullable|string|min:8', // Password is optional on update
        ]);

        $user->update([
            'name' => $validated['name'],
            'email' => $validated['email'],
        ]);

        if (!empty($validated['password'])) {
            $user->password = $validated['password']; // Hashing is handled by the model
            $user->save();
        }

        return response()->json($user);
    }

    /**
     * Delete a user.
     */
    public function destroy(User $user)
    {
        // Add a safeguard to prevent deleting a superadmin
        if ($user->role->name === 'superadmin') {
            return response()->json(['error' => 'Cannot delete a superadmin.'], 403);
        }

        $user->delete();

        return response()->json(null, 204);
    }
}  

C:\xampp\htdocs\Online-Registration-System\backend\app\Models\Role.php 

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Role extends Model
{
    use HasFactory;

    protected $fillable = [
        'name', 'permissions', 'description',
    ];

    protected $casts = [
        'permissions' => 'array',  // JSON to array
    ];

    // Relationship
    public function users()
    {
        return $this->hasMany(User::class);
    }
}
 
C:\xampp\htdocs\Online-Registration-System\backend\app\Models\User.php  

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
use Illuminate\Support\Facades\Crypt;

class User extends Authenticatable
{
    /** @use HasFactory<\Database\Factories\UserFactory> */
    use HasApiTokens, HasFactory, Notifiable;

    /**
     * Always eager load these relationships.
     *
     * This ensures Auth::user() and Sanctum tokens
     * always include the role without lazy-loading issues.
     */
    protected $with = ['role'];

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'name',
        'email',
        'phone',
        'password',
        'role_id',
        'created_by',
    ];

    protected $guarded = [
        'status',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var list<string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
        ];
    }

    // Added phone encryption
    public function setPhoneAttribute($value)
    {
        $this->attributes['phone'] = $value ? Crypt::encryptString($value) : null;
    }

    public function getPhoneAttribute($value)
    {
        return $value ? Crypt::decryptString($value) : null;
    }
    // 🔹 Relationships
    public function role()
    {
        return $this->belongsTo(Role::class);
    }

    public function registrations()
    {
        return $this->hasMany(Registration::class, 'registered_by');
    }

    public function scans()
    {
        return $this->hasMany(Scan::class, 'scanned_by');
    }

    public function logs()
    {
        return $this->hasMany(Log::class);
    }
}
 

C:\xampp\htdocs\Online-Registration-System\backend\app\Providers\AuthServiceProvider.php 

<?php

namespace App\Providers;

use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Gate;
use App\Models\User;
use App\Enums\Permission; // <-- 1. Import our new Permission Enum

class AuthServiceProvider extends ServiceProvider
{
    /**
     * The policy mappings for the application.
     *
     * @var array<class-string, class-string>
     */
    protected $policies = [
        // 'App\Models\Model' => 'App\Policies\ModelPolicy',
    ];

    /**
     * Register any authentication / authorization services.
     */
    public function boot(): void
    {
        $this->registerPolicies();

        // This Gate correctly gives the 'root' Super Admin (from .env) all permissions.
        Gate::before(function (User $user, string $ability) {
            if ($user->email === env('SUPERADMIN_EMAIL')) {
                return true;
            }
            return null; // Important: return null to allow other gates to run
        });

        // --- THE FIX ---
        // We define the gates directly, which is the most reliable method.
        // It's more verbose but completely avoids the closure issue.

        // Dashboard
        Gate::define('view-dashboard', fn(User $user) => in_array('view-dashboard', $user->role->permissions ?? []));

        // Registrations
        Gate::define('view-registrations', fn(User $user) => in_array('view-registrations', $user->role->permissions ?? []));
        Gate::define('create-registration', fn(User $user) => in_array('create-registration', $user->role->permissions ?? []));
        Gate::define('edit-registration', fn(User $user) => in_array('edit-registration', $user->role->permissions ?? []));
        Gate::define('delete-registration', fn(User $user) => in_array('delete-registration', $user->role->permissions ?? []));

        // User Management
        Gate::define('view-users', fn(User $user) => in_array('view-users', $user->role->permissions ?? []));
        Gate::define('create-user', fn(User $user) => in_array('create-user', $user->role->permissions ?? []));
        Gate::define('edit-user', fn(User $user) => in_array('edit-user', $user->role->permissions ?? []));
        Gate::define('delete-user', fn(User $user) => in_array('delete-user', $user->role->permissions ?? []));
        Gate::define('manage-roles', fn(User $user) => in_array('manage-roles', $user->role->permissions ?? []));

        // Settings
        Gate::define('view-settings', fn(User $user) => in_array('view-settings', $user->role->permissions ?? []));
        Gate::define('edit-settings', fn(User $user) => in_array('edit-settings', $user->role->permissions ?? []));

        // Server Mode
        Gate::define('view-server-mode', fn(User $user) => in_array('view-server-mode', $user->role->permissions ?? []));
        Gate::define('edit-server-mode', fn(User $user) => in_array('edit-server-mode', $user->role->permissions ?? []));
    }
}  

C:\xampp\htdocs\Online-Registration-System\backend\database\migrations\2025_08_15_000001_create_users_table.php 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            // Link to roles table
            $table->foreignId('role_id')->constrained('roles')->cascadeOnUpdate()->restrictOnDelete();
            
            // User basic information
            $table->string('name'); // Full name of the user
            $table->string('email')->unique()->index(); // Added index for search performance
            $table->timestamp('email_verified_at')->nullable(); // Timestamp when the email was verified
            $table->string('password', 255)->nullable(); // Keep nullable if some users (attendees) don’t need login 
            $table->string('phone', 1000)->nullable(); // Increased length for encryption

            // User account status
            $table->enum('status', ['active', 'inactive'])->default('active')->index(); 

            // Remember token for password reset
            $table->rememberToken();

            // Track who created this user (self-referencing FK)
            $table->foreignId('created_by')->nullable()->constrained('users')->nullOnDelete();

            $table->timestamps();
        });

        Schema::create('password_reset_tokens', function (Blueprint $table) {
            $table->string('email', 150)->primary();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
        });

        Schema::create('sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignId('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('users');
        Schema::dropIfExists('password_reset_tokens');
        Schema::dropIfExists('sessions');
    }
}; 

C:\xampp\htdocs\Online-Registration-System\backend\database\migrations\2025_08_15_000000_create_roles_table.php 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('roles', function (Blueprint $table) {
            $table->id(); // Primary key

            // Role Details
            $table->string('name', 50)->unique()->comment('Role name: Super Admin, Admin, User'); // Added unique constraint
            $table->json('permissions')->nullable()->comment('Storing Permission in JSON Format');
            $table->text('description')->nullable()->comment('Description of the role');
            $table->timestamps(); // Create_at, Updated_at timestamps
            
            $table->index('created_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('roles');
    }
}; 

C:\xampp\htdocs\Online-Registration-System\backend\database\seeders\RolesSeeder.php 

<?php

namespace Database\Seeders;

use App\Models\Role;
use Illuminate\Database\Seeder;
use App\Enums\Permission; // <-- Import our new Permission Enum

class RolesSeeder extends Seeder
{
    public function run(): void
    {
        // The 'superadmin' role gets all permissions.
        Role::updateOrCreate(
            ['name' => 'superadmin'],
            [
                'description' => 'Full System Control',
                'permissions' => Permission::all(), // <-- Assigns all permissions from the Enum
            ]
        );

        // The 'admin' role gets a specific, limited set of permissions.
        Role::updateOrCreate(
            ['name' => 'admin'],
            [
                'description' => 'Event operations and Monitoring',
                'permissions' => [
                    Permission::VIEW_DASHBOARD->value,
                    Permission::VIEW_REGISTRATIONS->value,
                    Permission::CREATE_REGISTRATION->value,
                    Permission::EDIT_REGISTRATION->value,
                    // Note: We are intentionally NOT giving them delete permissions by default.
                ],
            ]
        );

        // The 'user' role for attendees has no specific system permissions.
        Role::updateOrCreate(
            ['name' => 'user'],
            [
                'description' => 'Attendee / Registrant',
                'permissions' => [], // <-- Correctly an empty array
            ]
        );
    }
} 

C:\xampp\htdocs\Online-Registration-System\backend\database\seeders\TestDataSeeder.php 

<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\User;
use App\Models\Registration;
use App\Models\Scan;
use App\Models\Role;
use App\Models\PrintStatus;
use Carbon\Carbon;
use Faker\Factory as Faker;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Hash;


class TestDataSeeder extends Seeder
{
    public function run(): void
    {
        $faker = Faker::create();

        $adminRoleId = Role::where('name', 'admin')->value('id');
        $userRoleId = Role::where('name', 'user')->value('id');
        $superAdmin = User::where('email', env('SUPERADMIN_EMAIL', 'superadmin@dev.com'))->first();
        $badgePrintedStatusId = PrintStatus::where('type', 'badge')->where('name', 'printed')->value('id');
        $ticketPrintedStatusId = PrintStatus::where('type', 'ticket')->where('name', 'printed')->value('id');

        if (!$superAdmin) {
            $this->command->error('SuperAdmin not found, cannot seed test data.');
            return;
        }

        // Create Admins with encrypted fields
        for ($i = 0; $i < 3; $i++) {
            User::create([
                'role_id' => $adminRoleId,
                'name' => $faker->name,
                'email' => $faker->unique()->safeEmail,
                'email_verified_at' => Carbon::now(),
                'password' => Hash::make('password'), // Will be hashed
                'phone' => $faker->phoneNumber, // Will be encrypted
                'status' => 'active',
                'created_by' => $superAdmin->id,
            ]);
        }

        // Create Users and their Registrations with encrypted fields
        for ($i = 0; $i < 10; $i++) {
            $email = $faker->unique()->safeEmail;
            $user = User::create([
                'role_id' => $userRoleId,
                'name' => $faker->name,
                'email' => $email,
                'password' => Hash::make('password'), // Will be hashed
                'phone' => $faker->phoneNumber, // Will be encrypted
                'status' => 'active',
                'created_by' => $superAdmin->id,
            ]);

            $registration = Registration::create([
                'first_name' => $faker->firstName,
                'last_name' => $faker->lastName,
                'email' => $email, // Will be encrypted
                'email_hash' => hash('sha256', strtolower(trim($email))), // Consistent hash
                'phone' => $faker->phoneNumber, // Will be encrypted
                'address' => $faker->address, // Will be encrypted
                'registration_type' => $faker->randomElement(['onsite', 'online', 'pre-registered']),
                'server_mode' => 'onsite',
                'ticket_number' => 'TICKET-' . strtoupper(Str::random(12)),
                'registered_by' => $superAdmin->id,
                'badge_printed_status_id' => $badgePrintedStatusId,
                'ticket_printed_status_id' => $ticketPrintedStatusId,
                'confirmed' => $faker->boolean(50),
                'confirmed_by' => $faker->boolean(50) ? $superAdmin->id : null,
                'confirmed_at' => $faker->boolean(50) ? Carbon::now() : null,
            ]);

            if ($faker->boolean(50)) {
                Scan::create([
                    'registration_id' => $registration->id,
                    'scanned_by' => $faker->boolean(50) ? $superAdmin->id : User::where('role_id', $adminRoleId)->inRandomOrder()->first()->id,
                    'scanned_time' => Carbon::now()->subHours($faker->numberBetween(1, 24)),
                    'badge_printed_status_id' => $badgePrintedStatusId,
                    'ticket_printed_status_id' => $ticketPrintedStatusId,
                ]);
            }
        }
    }
} 

C:\xampp\htdocs\Online-Registration-System\backend\routes\api.php 

<?php

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
use App\Http\Controllers\AuthController;
use App\Http\Controllers\DashboardController;
use App\Http\Controllers\RegistrationController;
use App\Http\Controllers\ServerModeController;
use App\Http\Controllers\BadgeController;
use App\Http\Controllers\UserController;
use App\Http\Controllers\SettingController;
use App\Http\Controllers\RoleController;

/*
|--------------------------------------------------------------------------
| API Routes
|--------------------------------------------------------------------------
*/

// --- PUBLIC ROUTES ---
Route::get('/test', fn () => response()->json(['message' => 'API is working!']));
Route::post('/auth/login', [AuthController::class, 'login'])->name('login');
Route::get('/registrations/{ticketNumber}/badge', [BadgeController::class, 'show'])->name('registrations.badge');
Route::post('/registrations', [RegistrationController::class, 'store'])
     ->name('registrations.store')
     ->middleware('throttle:10,1');


// --- PROTECTED ROUTES ---
Route::middleware(['auth:sanctum', 'throttle:60,1'])->group(function () {
    
    Route::post('/auth/logout', [AuthController::class, 'logout'])->name('logout');
    Route::get('/me', fn (Request $request) => $request->user()->load('role'));

    // --- User Management ---
    Route::get('/users', [UserController::class, 'index'])->middleware('can:view-users');
    Route::post('/users', [UserController::class, 'store'])->middleware('can:create-user');
    Route::put('/users/{user}', [UserController::class, 'update'])->middleware('can:edit-user');
    Route::delete('/users/{user}', [UserController::class, 'destroy'])->middleware('can:delete-user');

    // --- Role & Permission Management ---
    Route::prefix('roles')->middleware('can:manage-roles')->group(function () {
        Route::get('/', [RoleController::class, 'index']);
        Route::put('/{role}', [RoleController::class, 'update']);
    });
    Route::get('/permissions', [RoleController::class, 'getAllPermissions'])->middleware('can:manage-roles');

    // --- Settings ---
    Route::get('/settings', [SettingController::class, 'index'])->middleware('can:view-settings');
    Route::post('/settings', [SettingController::class, 'update'])->middleware('can:edit-settings');
        
    // --- Server Mode Management ---
    Route::prefix('server-mode')->group(function () {
        Route::get('/', [ServerModeController::class, 'getCurrentMode'])->middleware('can:view-server-mode');
        Route::post('/', [ServerModeController::class, 'setMode'])->middleware('can:edit-server-mode');
        Route::get('/history', [ServerModeController::class, 'getHistory'])->middleware('can:edit-server-mode');
    });

    // --- Dashboard Routes ---
    Route::prefix('dashboard')->middleware('can:view-dashboard')->group(function () {
        Route::get('/summary', [DashboardController::class, 'summary']);
        Route::get('/registrations', [DashboardController::class, 'registrationsBreakdown']);
        Route::get('/print-statuses', [DashboardController::class, 'printStatusBreakdown']);
        Route::get('/scans-per-user', [DashboardController::class, 'scansPerUser']);
        Route::get('/logs', [DashboardController::class, 'logs']);
        Route::get('/stats', [DashboardController::class, 'stats']);
        Route::post('/upload-logo', [DashboardController::class, 'uploadLogo']); // <-- THIS ROUTE IS NOW CORRECTLY PLACED
        Route::get('/logos', [DashboardController::class, 'getLogos']);
    });

    // --- Admin Registration Routes ---
    Route::prefix('registrations')->group(function () {
        Route::get('/', [RegistrationController::class, 'index'])->middleware('can:view-registrations');
        Route::get('/{registration:ticket_number}', [RegistrationController::class, 'show'])->middleware('can:view-registrations');
        Route::post('/{ticket_number}/scan', [RegistrationController::class, 'scan'])->middleware('can:view-registrations');
        
        // Actions requiring higher privileges
        Route::put('/{registration}', [RegistrationController::class, 'update'])->middleware('can:edit-registration');
        Route::delete('/{registration}', [RegistrationController::class, 'destroy'])->middleware('can:delete-registration');
    });
}); 

C:\xampp\htdocs\Online-Registration-System\frontend\src\App.jsx 

import { BrowserRouter as Router, Routes, Route, Link } from "react-router-dom";
import { AuthProvider, useAuth } from "./context/AuthContext";
import ProtectedRoute from "./ProtectedRoute";

// Import all pages
import Home from "./pages/Home";
import LoginPage from "./pages/LoginPage";
import AdminPage from "./pages/AdminPage";
import SuperadminPage from "./pages/SuperadminPage";
import Unauthorized from "./pages/Unauthorized";
import DashboardPage from "./pages/DashboardPage";
import Registrations from "./pages/Registrations";
import RegistrationForm from "./pages/RegistrationForm";
import ServerModeManager from "./pages/ServerModeManager"; 
import UserManagementPage from "./pages/UserManagementPage";
import SettingsPage from "./pages/SettingsPage";
import OnsiteRegistrationPage from './pages/OnsiteRegistrationPage';
import OnlineRegistrationPage from './pages/OnlineRegistrationPage';
import RoleManagementPage from './pages/RoleManagementPage';
import DashboardLayout from "./pages/DashboardLayout";


// 🔹 NavBar Component
function NavBar() {
  const { user, logout } = useAuth();

  return (
    <nav style={{ padding: "10px", borderBottom: "1px solid #ccc", display: "flex", alignItems: "center" }}>
      <Link to="/">Home</Link>

      {user ? (
        <>
          &nbsp;|&nbsp;<Link to="/dashboard">Dashboard</Link>
          <div style={{ marginLeft: "auto" }}>
            <span>Welcome, {user.name}!</span>
            <button onClick={logout} style={{ marginLeft: '15px' }}>
              Logout
            </button>
          </div>
        </>
      ) : (
        <>&nbsp;|&nbsp;<Link to="/login">Login</Link></>
      )}
    </nav>
  );
}


function App() {
  return (
    <AuthProvider>
      <Router>
        <NavBar />

        <Routes>
          {/* Public Routes */}
          <Route path="/" element={<Home />} />
          <Route path="/login" element={<LoginPage />} />
          <Route path="/unauthorized" element={<Unauthorized />} />
          <Route path="/onsite" element={<OnsiteRegistrationPage />} />
          <Route path="/online" element={<OnlineRegistrationPage />} />

          {/* Protected Dashboard Routes are now nested */}
          <Route 
            path="/dashboard" 
            element={
              <ProtectedRoute roles={["admin", "superadmin"]}>
                <DashboardLayout />
              </ProtectedRoute>
            }
          >
            {/* The 'index' is the default page shown at /dashboard */}
            <Route index element={<DashboardPage />} /> 

            {/* All other admin pages are now children of /dashboard */}
            <Route path="registrations" element={<Registrations />} />
            <Route path="register-new" element={<RegistrationForm />} />
            <Route path="user-management" element={<UserManagementPage />} />
            <Route path="role-management" element={<RoleManagementPage />} />
            <Route path="settings" element={<SettingsPage />} />
            <Route path="server-mode" element={<ServerModeManager />} />
    
            {/* The old /admin and /superadmin pages can be removed or kept as needed */}
            <Route path="admin" element={<AdminPage />} />
            <Route path="superadmin" element={<SuperadminPage />} />
          </Route>
        </Routes>
      </Router>
    </AuthProvider>
  );
}

export default App; 






-----------------------------------------------------------------------------------






10/11/2025 

I'm using laravel for backend, React For frontend  

C:\xampp\htdocs\Online-Registration-System\backend\app\Enums\Permission.php 

<?php

namespace App\Enums;
use Illuminate\Support\Facades\Gate;

enum Permission: string
{

    public function boot(): void
{
    foreach (Permission::cases() as $permission) {
        Gate::define($permission->value, function ($user) use ($permission) {
            $rolePermissions = json_decode($user->role?->permissions ?? '[]');
            return in_array($permission->value, $rolePermissions);
        });
    }
}
    // Dashboard Permissions
    case VIEW_DASHBOARD = 'view-dashboard';

    // Registration Permissions
    case VIEW_REGISTRATIONS = 'view-registrations';
    case CREATE_REGISTRATION = 'create-registration';
    case EDIT_REGISTRATION = 'edit-registration';
    case DELETE_REGISTRATION = 'delete-registration';

    // User Management Permissions
    case VIEW_USERS = 'view-users';
    case CREATE_USER = 'create-user';
    case EDIT_USER = 'edit-user';
    case DELETE_USER = 'delete-user';

    // Settings Permissions
    case VIEW_SETTINGS = 'view-settings';
    case EDIT_SETTINGS = 'edit-settings';

    // Server Mode Permissions
    case VIEW_SERVER_MODE = 'view-server-mode';
    case EDIT_SERVER_MODE = 'edit-server-mode';

    // Role Management Permissions
    case MANAGE_ROLES = 'manage-roles';

    /**
     * Helper function to get all permission values as an array.
     * Useful for seeding the database.
     */
    public static function all(): array
    {
        return array_column(self::cases(), 'value');
    }
} 

C:\xampp\htdocs\Online-Registration-System\backend\app\Http\Controllers\AuthController.php 

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class AuthController extends Controller
{
    /**
     * Handle login and return a Sanctum token
     */
    public function login(Request $request)
    {
        $credentials = $request->validate([
            'email'    => 'required|email',
            'password' => 'required|string',
        ]);

        if (!Auth::attempt($credentials)) {
            return response()->json(['message' => 'Invalid credentials'], 401);
        }

        /** @var \App\Models\User $user */
        $user = Auth::user();

        // 🔹 Create a fresh token
        $token = $user->createToken('api-token')->plainTextToken;

        return response()->json([
            'user'  => $user->load('role'),
            'token' => $token,
        ]);
    }

    /**
     * Handle logout and revoke the Sanctum token
     */
    public function logout(Request $request)
    {
        $user = $request->user();

        if ($user) {
            // 🔹 If currentAccessToken exists, delete it
            $token = $user->currentAccessToken();
            if ($token) {
                $token->delete();
            }

            return response()->json(['message' => 'Logged out successfully']);
        }

        return response()->json(['message' => 'Unauthorized'], 401);
    }
} 

C:\xampp\htdocs\Online-Registration-System\backend\app\Http\Controllers\RoleController.php  

<?php

namespace App\Http\Controllers;

use App\Models\Role;
use Illuminate\Http\Request;
use App\Enums\Permission;

class RoleController extends Controller
{
    /**
     * List all editable roles.
     */
    public function index()
    {
        // We exclude the 'user' role as it has no system permissions to edit.
        $roles = Role::where('name', '!=', 'user')->get();
        return response()->json($roles);
    }

    /**
     * Update the permissions for a specific role.
     */
    public function update(Request $request, Role $role)
    {
        $validated = $request->validate([
            'permissions' => 'required|array',
            'permissions.*' => 'string', // Ensure all items in the array are strings
        ]);
        
        // This is a safeguard. It prevents the 'root' superadmin from accidentally
        // removing all permissions from the 'superadmin' role itself.
        if ($role->name === 'superadmin') {
            $validated['permissions'] = Permission::all();
        }

        $role->update(['permissions' => $validated['permissions']]);

        return response()->json($role);
    }

    /**
     * Provide a list of all available permissions from the Enum.
     */
    public function getAllPermissions()
    {
        return response()->json(Permission::all());
    }
}

C:\xampp\htdocs\Online-Registration-System\backend\app\Http\Controllers\UserController.php 

<?php

namespace App\Http\Controllers;

use App\Models\User;
use App\Models\Role;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rule;
use Illuminate\Support\Facades\Auth;

class UserController extends Controller
{
    /**
     * List all users (excluding the superadmin role).
     */
    public function index()
    {
        $adminRole = Role::where('name', 'admin')->first();
        if (!$adminRole) {
            return response()->json(['users' => []]);
        }
        
        $users = User::where('role_id', $adminRole->id)->latest()->paginate(25);
        return response()->json($users);
    }

    /**
     * Create a new admin user.
     */
    public function store(Request $request)
{
    $validated = $request->validate([
        'name' => 'required|string|max:255',
        'email' => 'required|string|email|max:255|unique:users',
        'password' => 'required|string|min:8',
        'role_id' => 'required|integer|exists:roles,id',
    ]);

    $user = User::create([
        'name' => $validated['name'],
        'email' => $validated['email'],
        'password' => $validated['password'],
        'role_id' => $validated['role_id'],
        'created_by' => Auth::id(),
    ]);

    // 🔹 Automatically generate a Sanctum token for the new user
    $token = $user->createToken('auto-generated-token')->plainTextToken;

    return response()->json([
        'message' => 'User created successfully.',
        'user' => $user->load('role'),
        'token' => $token,
    ], 201);
}

    /**
     * Update a user's information.
     */
    public function update(Request $request, User $user)
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'email' => ['required', 'string', 'email', 'max:255', Rule::unique('users')->ignore($user->id)],
            'password' => 'nullable|string|min:8', // Password is optional on update
        ]);

        $user->update([
            'name' => $validated['name'],
            'email' => $validated['email'],
        ]);

        if (!empty($validated['password'])) {
            $user->password = $validated['password']; // Hashing is handled by the model
            $user->save();
        }

        return response()->json($user);
    }

    /**
     * Delete a user.
     */
    public function destroy(User $user)
    {
        // Add a safeguard to prevent deleting a superadmin
        if ($user->role->name === 'superadmin') {
            return response()->json(['error' => 'Cannot delete a superadmin.'], 403);
        }

        $user->delete();

        return response()->json(null, 204);
    }
} 

C:\xampp\htdocs\Online-Registration-System\backend\app\Models\Role.php 

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Role extends Model
{
    use HasFactory;

    protected $fillable = [
        'name', 'permissions', 'description',
    ];

    protected $casts = [
        'permissions' => 'array',  // JSON to array
    ];

    // Relationship
    public function users()
    {
        return $this->hasMany(User::class);
    }
} 

C:\xampp\htdocs\Online-Registration-System\backend\app\Models\User.php 

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
use Illuminate\Support\Facades\Crypt;

class User extends Authenticatable
{
    /** @use HasFactory<\Database\Factories\UserFactory> */
    use HasApiTokens, HasFactory, Notifiable;

    /**
     * Always eager load these relationships.
     *
     * This ensures Auth::user() and Sanctum tokens
     * always include the role without lazy-loading issues.
     */
    protected $with = ['role'];

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'name',
        'email',
        'phone',
        'password',
        'role_id',
        'created_by',
    ];

    protected $guarded = [
        'status',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var list<string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
        ];
    }

    // Added phone encryption
    public function setPhoneAttribute($value)
    {
        $this->attributes['phone'] = $value ? Crypt::encryptString($value) : null;
    }

    public function getPhoneAttribute($value)
    {
        return $value ? Crypt::decryptString($value) : null;
    }
    // 🔹 Relationships
    public function role()
    {
        return $this->belongsTo(Role::class);
    }

    public function registrations()
    {
        return $this->hasMany(Registration::class, 'registered_by');
    }

    public function scans()
    {
        return $this->hasMany(Scan::class, 'scanned_by');
    }

    public function logs()
    {
        return $this->hasMany(Log::class);
    }
}


C:\xampp\htdocs\Online-Registration-System\backend\app\Models\ServerMode.php 

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class ServerMode extends Model
{
    use HasFactory;

    protected $fillable = ['mode', 'activated_by'];

    protected $casts = [
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    // relationship
    public function activatedBy()
    {
        return $this->belongsTo(User::class, 'activated_by');
    }
} 

C:\xampp\htdocs\Online-Registration-System\backend\database\seeders\RolesSeeder.php 

<?php

namespace Database\Seeders;

use App\Models\Role;
use Illuminate\Database\Seeder;
use App\Enums\Permission; // <-- Import our new Permission Enum

class RolesSeeder extends Seeder
{
    public function run(): void
    {
        // The 'superadmin' role gets all permissions.
        Role::updateOrCreate(
            ['name' => 'superadmin'],
            [
                'description' => 'Full System Control',
                'permissions' => Permission::all(), // <-- Assigns all permissions from the Enum
            ]
        );

        // The 'admin' role gets a specific, limited set of permissions.
        Role::updateOrCreate(
            ['name' => 'admin'],
            [
                'description' => 'Event operations and Monitoring',
                'permissions' => [
                    Permission::VIEW_DASHBOARD->value,
                    Permission::VIEW_REGISTRATIONS->value,
                    Permission::CREATE_REGISTRATION->value,
                    Permission::EDIT_REGISTRATION->value,
                    // Note: We are intentionally NOT giving them delete permissions by default.
                ],
            ]
        );

        // The 'user' role for attendees has no specific system permissions.
        Role::updateOrCreate(
            ['name' => 'user'],
            [
                'description' => 'Attendee / Registrant',
                'permissions' => [], // <-- Correctly an empty array
            ]
        );
    }
}

C:\xampp\htdocs\Online-Registration-System\backend\database\seeders\ServerModesSeeder.php

<?php

namespace Database\Seeders;

use App\Models\ServerMode;
use App\Models\User;
use Illuminate\Database\Seeder;

class ServerModesSeeder extends Seeder
{
    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        // Find the Super Admin user to attribute the action to.
        $superAdmin = User::where('email', env('SUPERADMIN_EMAIL', 'superadmin@dev.com'))->first();

        if (!$superAdmin) {
            $this->command->warn("⚠️ SuperAdmin not found. Cannot seed the initial server mode.");
            return;
        }

        // --- CORRECTED LOGIC ---
        // We only want to seed ONE initial server mode. The 'firstOrCreate' method is
        // perfect for this. It checks if any server mode exists. If not, it creates
        // our specified default mode. If the table already has entries, it does nothing.
        // This makes the seeder safe to run multiple times.

        ServerMode::firstOrCreate(
            [], // No conditions, we just want to check if the table is empty.
            [
                'mode' => 'onsite', // Set 'onsite' as the default starting mode.
                'activated_by' => $superAdmin->id,
            ]
        );

        $this->command->info("✅ Initial server mode ensured.");
    }
} 

<?php

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
use App\Http\Controllers\AuthController;
use App\Http\Controllers\DashboardController;
use App\Http\Controllers\RegistrationController;
use App\Http\Controllers\ServerModeController;
use App\Http\Controllers\BadgeController;
use App\Http\Controllers\UserController;
use App\Http\Controllers\SettingController;
use App\Http\Controllers\RoleController;

/*
|--------------------------------------------------------------------------
| API Routes
|--------------------------------------------------------------------------
*/

// --- PUBLIC ROUTES ---
Route::get('/test', fn () => response()->json(['message' => 'API is working!']));

// 🔐 AUTH - Public
Route::prefix('auth')->group(function () {
    Route::post('/login', [AuthController::class, 'login'])->name('login');
});

// 🎫 Public badge printing
Route::get('/registrations/{ticketNumber}/badge', [BadgeController::class, 'show'])
    ->name('registrations.badge');

// 📝 Public registration form (rate limited)
Route::post('/registrations', [RegistrationController::class, 'store'])
    ->name('registrations.store')
    ->middleware('throttle:10,1');

// --- PROTECTED ROUTES ---
Route::middleware(['auth:sanctum', 'throttle:60,1'])->group(function () {

    /*
    |--------------------------------------------------------------------------
    | AUTH ROUTES
    |--------------------------------------------------------------------------
    */
    Route::prefix('auth')->group(function () {
        Route::post('/logout', [AuthController::class, 'logout'])->name('logout');

        // ✅ Used by React AuthContext → fetchUser()
        Route::get('/me', fn (Request $request) => $request->user()->load('role'));

        // Optional - debug only
        Route::get('/check', function (Request $request) {
            $user = $request->user()->load('role');
            return response()->json([
                'authenticated' => $user !== null,
                'user' => $user,
                'role' => $user?->role?->name,
                'permissions' => json_decode($user?->role?->permissions ?? '[]'),
            ]);
        });
    });

    /*
    |--------------------------------------------------------------------------
    | USER MANAGEMENT
    |--------------------------------------------------------------------------
    */
    Route::prefix('users')->group(function () {
        Route::get('/', [UserController::class, 'index'])->middleware('can:view-users');
        Route::post('/', [UserController::class, 'store'])->middleware('can:create-user');
        Route::put('/{user}', [UserController::class, 'update'])->middleware('can:edit-user');
        Route::delete('/{user}', [UserController::class, 'destroy'])->middleware('can:delete-user');
    });

    /*
    |--------------------------------------------------------------------------
    | ROLE & PERMISSION MANAGEMENT
    |--------------------------------------------------------------------------
    */
    Route::prefix('roles')->middleware('can:manage-roles')->group(function () {
        Route::get('/', [RoleController::class, 'index']);
        Route::put('/{role}', [RoleController::class, 'update']);
    });
    Route::get('/permissions', [RoleController::class, 'getAllPermissions'])
        ->middleware('can:manage-roles');

    /*
    |--------------------------------------------------------------------------
    | SETTINGS
    |--------------------------------------------------------------------------
    */
    Route::prefix('settings')->group(function () {
        Route::get('/', [SettingController::class, 'index'])->middleware('can:view-settings');
        Route::post('/', [SettingController::class, 'update'])->middleware('can:edit-settings');
    });

    /*
    |--------------------------------------------------------------------------
    | SERVER MODE MANAGEMENT
    |--------------------------------------------------------------------------
    */
    Route::prefix('server-mode')->group(function () {
        Route::get('/', [ServerModeController::class, 'getCurrentMode'])
            ->middleware('can:view-server-mode');
        Route::post('/', [ServerModeController::class, 'setMode'])
            ->middleware('can:edit-server-mode');
        Route::get('/history', [ServerModeController::class, 'getHistory'])
            ->middleware('can:edit-server-mode');
    });

    /*
    |--------------------------------------------------------------------------
    | DASHBOARD
    |--------------------------------------------------------------------------
    */
    Route::prefix('dashboard')->middleware('can:view-dashboard')->group(function () {
        Route::get('/summary', [DashboardController::class, 'summary']);
        Route::get('/registrations', [DashboardController::class, 'registrationsBreakdown']);
        Route::get('/print-statuses', [DashboardController::class, 'printStatusBreakdown']);
        Route::get('/scans-per-user', [DashboardController::class, 'scansPerUser']);
        Route::get('/logs', [DashboardController::class, 'logs']);
        Route::get('/stats', [DashboardController::class, 'stats']);
        Route::post('/upload-logo', [DashboardController::class, 'uploadLogo']);
        Route::get('/logos', [DashboardController::class, 'getLogos']);
    });

    /*
    |--------------------------------------------------------------------------
    | REGISTRATION MANAGEMENT (Admin)
    |--------------------------------------------------------------------------
    */
    Route::prefix('registrations')->group(function () {
        Route::get('/', [RegistrationController::class, 'index'])->middleware('can:view-registrations');
        Route::get('/{registration:ticket_number}', [RegistrationController::class, 'show'])
            ->middleware('can:view-registrations');
        Route::post('/{ticket_number}/scan', [RegistrationController::class, 'scan'])
            ->middleware('can:view-registrations');
        Route::put('/{registration}', [RegistrationController::class, 'update'])
            ->middleware('can:edit-registration');
        Route::delete('/{registration}', [RegistrationController::class, 'destroy'])
            ->middleware('can:delete-registration');
    });
}); 

C:\xampp\htdocs\Online-Registration-System\frontend\src\api\axios.js 

// src/api/axios.js
import axios from "axios";

let logoutHandler = null; // 👈 will be set by AuthContext

export const setLogoutHandler = (handler) => {
  logoutHandler = handler;
};

// Create Axios instance
const api = axios.create({
  baseURL: "http://127.0.0.1:8000/api",
  headers: {
    "Content-Type": "application/json",
  },
});

// Request Interceptor - add Authorization automatically
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("token");
    if (token) {
      config.headers["Authorization"] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response Interceptor - handle 401/403 globally
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && [401, 403].includes(error.response.status)) {
      console.warn("🔒 Unauthorized or Forbidden. Logging out...");
      if (logoutHandler) logoutHandler(); // 👈 auto logout user
    }
    return Promise.reject(error);
  }
);

export default api; 

C:\xampp\htdocs\Online-Registration-System\frontend\src\context\AuthContext.jsx 

import { createContext, useContext, useState, useEffect, useCallback } from "react";
import api, { setLogoutHandler } from "../api/axios"; 

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [token, setToken] = useState(localStorage.getItem("token") || null);
  const [user, setUser] = useState(
    localStorage.getItem("user") ? JSON.parse(localStorage.getItem("user")) : null
  );
  const [loading, setLoading] = useState(true);

  // 🔹 Sync Axios global logout with our logout method
  const logout = useCallback(async () => {
    if (token) {
      try {
        await api.post("/auth/logout"); // no need for manual headers, Axios adds it
      } catch (err) {
        console.error("Logout error:", err);
      }
    }

    setToken(null);
    setUser(null);
    localStorage.removeItem("token");
    localStorage.removeItem("user");
  }, [token]);

  useEffect(() => {
    setLogoutHandler(logout); // 👈 register logout handler
  }, [logout]);

  // 🔹 Fetch user profile
  const fetchUser = useCallback(async () => {
    if (!token) return;
    try {
      const response = await api.get("/me"); // headers auto-attached
      setUser(response.data);
      localStorage.setItem("user", JSON.stringify(response.data));
    } catch (err) {
      console.error("Fetch user error:", err);
      logout();
    }
  }, [token, logout]);

  // 🔹 Restore user on mount
  useEffect(() => {
    const init = async () => {
      if (token && !user) {
        await fetchUser();
      }
      setLoading(false);
    };
    init();
  }, [token, user, fetchUser]);

  // 🔹 Login
  const login = async (email, password) => {
    try {
      const { data } = await api.post("/auth/login", { email, password });
      setToken(data.token);
      setUser(data.user);
      localStorage.setItem("token", data.token);
      localStorage.setItem("user", JSON.stringify(data.user));
      return true;
    } catch (err) {
      console.error("Login failed", err);
      return false;
    }
  };

  return (
    <AuthContext.Provider value={{ token, user, login, logout, fetchUser, loading }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  return useContext(AuthContext);
} 


C:\xampp\htdocs\Online-Registration-System\frontend\src\App.jsx 

import { BrowserRouter as Router, Routes, Route, Link } from "react-router-dom";
import { AuthProvider, useAuth } from "./context/AuthContext";
import ProtectedRoute from "./ProtectedRoute";

// Import all pages
import Home from "./pages/Home";
import LoginPage from "./pages/LoginPage";
import AdminPage from "./pages/AdminPage";
import SuperadminPage from "./pages/SuperadminPage";
import Unauthorized from "./pages/Unauthorized";
import DashboardPage from "./pages/DashboardPage";
import Registrations from "./pages/Registrations";
import RegistrationForm from "./pages/RegistrationForm";
import ServerModeManager from "./pages/ServerModeManager"; 
import UserManagementPage from "./pages/UserManagementPage";
import SettingsPage from "./pages/SettingsPage";
import OnsiteRegistrationPage from './pages/OnsiteRegistrationPage';
import OnlineRegistrationPage from './pages/OnlineRegistrationPage';
import RoleManagementPage from './pages/RoleManagementPage';
import DashboardLayout from "./pages/DashboardLayout";


// 🔹 NavBar Component
function NavBar() {
  const { user, logout } = useAuth();

  return (
    <nav style={{ padding: "10px", borderBottom: "1px solid #ccc", display: "flex", alignItems: "center" }}>
      <Link to="/">Home</Link>

      {user ? (
        <>
          &nbsp;|&nbsp;<Link to="/dashboard">Dashboard</Link>
          <div style={{ marginLeft: "auto" }}>
            <span>Welcome, {user.name}!</span>
            <button onClick={logout} style={{ marginLeft: '15px' }}>
              Logout
            </button>
          </div>
        </>
      ) : (
        <>&nbsp;|&nbsp;<Link to="/login">Login</Link></>
      )}
    </nav>
  );
}


function App() {
  return (
    <AuthProvider>
      <Router>
        <NavBar />

        <Routes>
          {/* Public Routes */}
          <Route path="/" element={<Home />} />
          <Route path="/login" element={<LoginPage />} />
          <Route path="/unauthorized" element={<Unauthorized />} />
          <Route path="/onsite" element={<OnsiteRegistrationPage />} />
          <Route path="/online" element={<OnlineRegistrationPage />} />

          {/* Protected Dashboard Routes are now nested */}
          <Route 
            path="/dashboard" 
            element={
              <ProtectedRoute roles={["admin", "superadmin"]}>
                <DashboardLayout />
              </ProtectedRoute>
            }
          >
            {/* The 'index' is the default page shown at /dashboard */}
            <Route index element={<DashboardPage />} /> 

            {/* All other admin pages are now children of /dashboard */}
            <Route path="registrations" element={<Registrations />} />
            <Route path="register-new" element={<RegistrationForm />} />
            <Route path="user-management" element={<UserManagementPage />} />
            <Route path="role-management" element={<RoleManagementPage />} />
            <Route path="settings" element={<SettingsPage />} />
            <Route path="server-mode" element={<ServerModeManager />} />

            {/* The old /admin and /superadmin pages can be removed or kept as needed */}
            <Route path="admin" element={<AdminPage />} />
            <Route path="superadmin" element={<SuperadminPage />} />
          </Route>
        </Routes>
      </Router>
    </AuthProvider>
  );
}

export default App; 


C:\xampp\htdocs\Online-Registration-System\frontend\src\ProtectedRoute.jsx 

import { Navigate } from "react-router-dom";
import { useAuth } from "./context/AuthContext";
import { useEffect, useState } from "react";

export default function ProtectedRoute({ children, roles }) {
  const { user, token, fetchUser } = useAuth();
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const init = async () => {
      if (token && !user) {
        await fetchUser();
      }
      setLoading(false);
    };
    init();
  }, [token, user, fetchUser]);

  if (loading) return <div>Loading...</div>;

  if (!token) return <Navigate to="/login" replace />;

  if (roles && user && !roles.includes(user?.role?.name)) {
    return <Navigate to="/unauthorized" replace />;
  }

  return children;
} 







10 / 16 / 17 




let's add another page Reports, First let's add more data needed in our DashboardController so we will display to new page report in our frontend 
here's the Migrated Tables 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('registrations', function (Blueprint $table) {
            $table->id();

            // Encrypted personal info
            $table->text('first_name');
            $table->text('last_name');
            $table->text('email');
            $table->text('phone')->nullable();
            $table->text('address')->nullable();

            $table->enum('registration_type', ['onsite','online','pre-registered'])->index();

            // Ticket / QR
            $table->string('ticket_number', 100)->unique()->nullable();
            $table->string('qr_code_path', 255)->nullable();

            $table->enum('server_mode', ['onsite','online','both'])->default('onsite')->index();

            // Print statuses
            $table->foreignId('badge_printed_status_id')->nullable()
                  ->constrained('print_statuses')->nullOnDelete();
            $table->foreignId('ticket_printed_status_id')->nullable()
                  ->constrained('print_statuses')->nullOnDelete();

            // Confirmation
            $table->boolean('confirmed')->default(false);
            $table->foreignId('confirmed_by')->nullable()
                  ->constrained('users')->nullOnDelete();
            $table->timestamp('confirmed_at')->nullable();

            // Who registered
            $table->foreignId('registered_by')->nullable()
                  ->constrained('users')->nullOnDelete();

            // Paid or Unpaid 
            $table->enum('payment_status', ['paid', 'unpaid'])->default('unpaid')->index();

            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('registrations');
    }
};  

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('print_statuses', function (Blueprint $table) {
            $table->id(); // Primary Key

            // Badge or Ticket status
            $table->enum('type', ['badge', 'ticket'])
                  ->comment('Defines whether this status applies to badges or tickets');

            // Status name (unique within type)
            $table->string('name', 50)
                  ->comment('E.g., not_printed, printed, reprinted');

            $table->text('description')->nullable()
                  ->comment('Optional description of the status meaning');

            // Active flag
            $table->tinyInteger('active')->default(1)
                 ->comment('1 = Active, 0 = Disabled');  // Added comment

            // Timestamps
            $table->timestamps();

            // Constraints & Indexes
            $table->unique(['type', 'name']); // Prevent duplicate status names for same type
            $table->index('type'); // Quick lookups by type
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('print_statuses');
    }
};

Backend modification
Basically we need to display this tables so The report will be perfect just help me add it to our Dashboardcontroller. 
also our RegistrationController Cause I just Recently add the payment_status 

Frontend modification

Search bar for specific data report
Printed counts 
Re-Printed counts 
paid counts 
unpaid counts
Total Registrant

then 
Table like Report, base it on the image I sent
Display all the needed data on the table, as you can see our migrations involved on this report 

and last but not the least this is the best part. add Export to pdf, 


Here's my current DashboardController 

<?php

namespace App\Http\Controllers;

use App\Models\User;
use App\Models\Registration;
use App\Models\ServerMode;
use App\Models\Scan;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Auth;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Cache;
use App\Models\Setting;



class DashboardController extends Controller
{

    public function __construct()
    {
        $this->middleware('auth:sanctum'); // Ensure authenticated user
    }
    /**
     * Dashboard summary (all key stats in one payload).
     */
    public function summary(): JsonResponse
    {
        try {
            $user = Auth::user();
        
            // Each user gets their own cache. A superadmin sees all, an admin sees their own.
            $cacheKey = "dashboard_summary:role_{$user->role->name}:user_{$user->id}";
        
            // Store the result for 10 minutes. If the key exists, it's returned instantly.
            // If not, the closure runs, and its result is stored and returned.
            $summaryData = Cache::remember($cacheKey, now()->addMinutes(10), function () use ($user) {
                $isSuperAdmin = $user->role->name === 'superadmin';
                $currentMode = ServerMode::latest()->first()->mode ?? 'onsite';
            
                $baseQuery = fn ($q) => $isSuperAdmin ? $q : $q->where('registered_by', $user->id);
            
                // The exact same queries from before, now inside the cache closure
                return [
                    'server_mode'           => $currentMode,
                    'registrations_by_type' => $baseQuery(Registration::select('registration_type', DB::raw('count(*) as total'))->groupBy('registration_type'))->get(),
                    'confirmed_vs_pending'  => $baseQuery(Registration::select('confirmed', DB::raw('count(*) as total'))->groupBy('confirmed'))->get(),
                    'badge_statuses'        => $baseQuery(Registration::select('badge_printed_status_id', DB::raw('count(*) as total'))->groupBy('badge_printed_status_id'))->get(),
                    'ticket_statuses'       => $baseQuery(Registration::select('ticket_printed_status_id', DB::raw('count(*) as total'))->groupBy('ticket_printed_status_id'))->get(),
                    'scans_per_user'        => User::withCount('scans')->get(),
                ];
            });
        
            return response()->json($summaryData);
        
        } 
        
        catch (\Exception $e) {
            Log::error('Dashboard summary error: ' . $e->getMessage());
            return response()->json([
                'error'   => 'Failed to fetch dashboard summary',
                'message' => $e->getMessage()
            ], 500);
            
            }
        }

    // ------------------------------
    // Queries extracted as reusable functions with role filtering
    // ------------------------------

    private function getRegistrationsByType(bool $isSuperAdmin)
    {
        $query = Registration::select('registration_type', DB::raw('count(*) as total'))
            ->groupBy('registration_type');
        return $isSuperAdmin ? $query->get() : $query->where('registered_by', Auth::id())->get();
    }

    private function getConfirmedVsPending(bool $isSuperAdmin)
    {
        $query = Registration::select('confirmed', DB::raw('count(*) as total'))
            ->groupBy('confirmed');
        return $isSuperAdmin ? $query->get() : $query->where('registered_by', Auth::id())->get();
    }

    private function getBadgeStatuses(bool $isSuperAdmin)
    {
        $query = Registration::select('badge_printed_status_id', DB::raw('count(*) as total'))
            ->groupBy('badge_printed_status_id');
        return $isSuperAdmin ? $query->get() : $query->where('registered_by', Auth::id())->get();
    }

    private function getTicketStatuses(bool $isSuperAdmin)
    {
        $query = Registration::select('ticket_printed_status_id', DB::raw('count(*) as total'))
            ->groupBy('ticket_printed_status_id');
        return $isSuperAdmin ? $query->get() : $query->where('registered_by', Auth::id())->get();
    }

    private function getScansPerUser(bool $isSuperAdmin)
    {
        $query = User::withCount('scans')
            ->select(['id', 'role_id', 'name', 'email', 'phone', 'status', 'created_by', 'created_at', 'updated_at']);
        return $isSuperAdmin ? $query->get() : $query->where('id', Auth::id())->get();
    }

    // ------------------------------
    // API endpoints reusing queries
    // ------------------------------

    public function registrationsBreakdown(): JsonResponse
    {
        try {
            return response()->json($this->getRegistrationsByType(Auth::user()->role->name === 'superadmin'));
        } catch (\Exception $e) {
            return response()->json([
                'error'   => 'Failed to fetch registration breakdown',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Detailed stats breakdown by ServerMode.
     */

     public function stats(): JsonResponse
     {
         try {
             $user = Auth::user();
             $isSuperAdmin = $user->role->name === 'superadmin';
             $currentMode = ServerMode::latest()->first()->mode ?? 'onsite';
 
             $baseQuery = fn ($q) => $isSuperAdmin ? $q : $q->where('registered_by', $user->id);
 
             return response()->json([
                 'server_mode' => $currentMode,
                 'total_registrations' => $baseQuery(Registration::query())->count(),
                 'by_mode' => Registration::select('server_mode', DB::raw('count(*) as total'))
                     ->groupBy('server_mode')
                     ->get(),
                 'active_users' => $baseQuery(User::where('status', 'active'))->count(),
                 'recent_scans' => Scan::where('scanned_time', '>', now()->subHours(24))->count(),
             ]);
         } catch (\Exception $e) {
             Log::error('Stats error: ' . $e->getMessage());
             return response()->json([
                 'error'   => 'Failed to fetch stats',
                 'message' => $e->getMessage()
             ], 500);
         }
     }
    

    public function printStatusBreakdown(): JsonResponse
    {
        try {
            $isSuperAdmin = Auth::user()->role->name === 'superadmin';
            return response()->json([
                'badge_statuses'  => $this->getBadgeStatuses($isSuperAdmin),
                'ticket_statuses' => $this->getTicketStatuses($isSuperAdmin),
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error'   => 'Failed to fetch print status breakdown',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Scans per user (admins & superadmin).
     */
    public function scansPerUser(): JsonResponse
    {
        try {
            return response()->json($this->getScansPerUser(Auth::user()->role->name === 'superadmin'));
        } catch (\Exception $e) {
            return response()->json([
                'error'   => 'Failed to fetch scans per user',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Logs endpoint for Super Admin.
     */
    public function logs(Request $request): JsonResponse
    {
        try {
            if (Auth::user()->role->name !== 'superadmin') {
                return response()->json(['error' => 'Unauthorized'], 403);
            }

            $logs = Log::with('user')
                ->when($request->input('action'), fn ($q) => $q->where('action', $request->input('action')))
                ->when($request->input('target_type'), fn ($q) => $q->where('target_type', $request->input('target_type')))
                ->when($request->input('user_id'), fn ($q) => $q->where('user_id', $request->input('user_id')))
                ->latest()
                ->paginate(50); // Paginate for better performance

            return response()->json($logs);
        } catch (\Exception $e) {
            Log::error('Logs error: ' . $e->getMessage());
            return response()->json([
                'error'   => 'Failed to fetch logs',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Upload logos for badge/ticket (Super Admin only).
     */
     public function uploadLogo(Request $request): JsonResponse
{
    try {
        if (Auth::user()->role->name !== 'superadmin') {
            return response()->json(['error' => 'Unauthorized'], 403);
        }

        $request->validate([
            'logo_type' => 'required|in:event,organizer,manager,registration',
            'logo_file' => 'required|image|max:2048', // Max 2MB
        ]);

        $logoType = $request->input('logo_type');
        $file = $request->file('logo_file');

        $settingKeyMap = [
            'event'        => 'main_logo_path',
            'organizer'    => 'organizer_logo_path',
            'manager'      => 'manager_logo_path',
            'registration' => 'registration_logo_path',
        ];

        $settingKey = $settingKeyMap[$logoType];

        // 1) Get old path from settings
        $existing = Setting::where('key', $settingKey)->first();
        $oldPath = $existing?->value; // may be 'logos/foo.png' or 'storage/logos/foo.png'

        // 2) Store new file on the 'public' disk → returns e.g. 'logos/new.png'
        // Use store() so we always save a clean relative path (no 'storage/' prefix)
        $newPath = $file->store('logos', 'public'); // e.g. 'logos/1700000000_event.png'

        // 3) Delete old file if exists
        if ($oldPath) {
            // normalize old path to a relative path under 'public' disk
            $oldRel = ltrim(str_replace('\\', '/', $oldPath), '/');
            $oldRel = preg_replace('#^storage/#i', '', $oldRel); // strip leading 'storage/'
            if ($oldRel && Storage::disk('public')->exists($oldRel)) {
                Storage::disk('public')->delete($oldRel);
            }
        }

        // 4) Save new path to settings (always relative)
        Setting::updateOrCreate(
            ['key' => $settingKey],
            ['value' => $newPath]
        );

        Log::info('Logo uploaded and setting updated', [
            'type' => $logoType,
            'path' => $newPath,
            'user_id' => Auth::id(),
        ]);

        return response()->json([
            'message' => 'Logo uploaded successfully',
            'path' => $newPath,                       // relative path for DB
            'url'  => asset('storage/' . $newPath),   // absolute URL for convenience
        ]);
    } catch (\Exception $e) {
        Log::error('Logo upload error: ' . $e->getMessage());
        return response()->json([
            'error'   => 'Failed to upload logo',
            'message' => $e->getMessage()
        ], 500);
    }
}

    /**
     * Retrieve available logos (for badge/ticket rendering).
     */
    public function getLogos(): JsonResponse
{
    try {
        $files = Storage::disk('public')->files('logos');
        $items = array_map(function ($path) {
            return [
                'path' => $path,                     // e.g., logos/foo.png
                'url'  => asset('storage/' . $path) // absolute URL
            ];
        }, $files);

        return response()->json(['logos' => $items]);
    } catch (\Exception $e) {
        Log::error('Get logos error: ' . $e->getMessage());
        return response()->json([
            'error'   => 'Failed to retrieve logos',
            'message' => $e->getMessage()
        ], 500);
    }
}

} 


<?php

namespace App\Http\Controllers;

use App\Models\Registration;
use App\Models\PrintStatus;
use App\Models\ServerMode;
use App\Models\Scan;
use Illuminate\Http\Request;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Crypt;
use App\Jobs\GenerateQrCode;
use Illuminate\Validation\Rule;

class RegistrationController extends Controller
{
    public function __construct()
    {
        $this->middleware('auth:sanctum')->except(['store']);
    }

    public function index(Request $request): JsonResponse
    {
        $perPage = $request->validate(['per_page' => 'integer|min:10|max:100'])['per_page'] ?? 50;
        $registrations = Registration::with(['badgeStatus', 'ticketStatus'])->latest()->paginate($perPage);
        return response()->json($registrations);
    }

    public function store(Request $request): JsonResponse
        {
            $validated = $request->validate([
                'first_name' => 'required|string|max:255',
                'last_name' => 'required|string|max:255',
                'email' => 'required|email|max:255|unique:registrations,email',
                'phone' => 'nullable|string|max:20',
                'address' => 'nullable|string|max:255',
                'company_name' => 'nullable|string|max:255',
                'registration_type' => 'required|in:onsite,online,pre-registered',
                'payment_status' => 'nullable|in:unpaid,paid',
            ]);

            // Check for duplicate email hash
            $emailHash = hash('sha256', strtolower(trim($validated['email'])));
            if (Registration::where('email_hash', $emailHash)->exists()) {
                return response()->json(['error' => 'This email address is already registered.'], 409);
            }

            // ServerMode validation
            $serverMode = ServerMode::latest()->first();
            if (!$serverMode) {
                return response()->json(['error' => 'Server mode not configured.'], 500);
            }
            $allowedTypes = explode(',', str_replace('both', 'onsite,online', $serverMode->mode));
            if (!in_array($validated['registration_type'], $allowedTypes)) {
                return response()->json(['error' => 'Registration type not allowed in current mode'], 400);
            }

            // PrintStatus setup
            $badgeNotPrinted = PrintStatus::where('type', 'badge')->where('name', 'not_printed')->first();
            $ticketNotPrinted = PrintStatus::where('type', 'ticket')->where('name', 'not_printed')->first();
            if (!$badgeNotPrinted || !$ticketNotPrinted) {
                return response()->json(['error' => 'Print statuses not configured.'], 500);
            }

            // Create Registration first
            $ticketNumber = 'TICKET-' . strtoupper(Str::random(12));
            $registration = Registration::create([
                'first_name' => $validated['first_name'],
                'last_name' => $validated['last_name'],
                'email' => $validated['email'],
                'email_hash' => $emailHash,
                'phone' => $validated['phone'],
                'address' => $validated['address'],
                'company_name' => $validated['company_name'],
                'registration_type' => $validated['registration_type'],
                'server_mode' => $serverMode->mode,
                'badge_printed_status_id' => $badgeNotPrinted->id,
                'ticket_printed_status_id' => $ticketNotPrinted->id,
                'ticket_number' => $ticketNumber,
                'registered_by' => Auth::id(),
                'payment_status' => $validated['payment_status'] ?? 'unpaid',
            ]);

            // ✅ Dispatch a job to handle QR code generation in the background
           (new GenerateQrCode($registration))->handle();


            Log::info('Registration created and QR job dispatched', [
                'ticket_number' => $ticketNumber,
                'user_id' => Auth::id(),
                'mode' => $serverMode->mode
            ]);
            
            $fresh = $registration->fresh();
            
            // Normalize path and build a web URL if available
            $qrUrl = $fresh->qr_code_path
                ? asset('storage/' . ltrim(str_replace('\\', '/', $fresh->qr_code_path), '/'))
                : null;
            
            return response()->json([
                'message' => 'Registration successful. The QR code will be generated shortly.',
                'registration' => array_merge($fresh->toArray(), [
                    'qr_url' => $qrUrl,
                ]),
            ], 201);
        }
        
        public function show($ticketNumber): JsonResponse
            {
                $registration = Registration::where('ticket_number', $ticketNumber)->firstOrFail();
                return response()->json([
                    'message' => 'Registration retrieved successfully',
                    'registration' => $registration,
                ]);
            }

        public function update(Request $request, Registration $registration)
            {
                $validated = $request->validate([
                    'first_name' => 'required|string|max:255',
                    'last_name' => 'required|string|max:255',
                    'email' => ['required', 'email', 'max:255', Rule::unique('registrations')->ignore($registration->id)],
                    'phone' => 'nullable|string|max:20',
                    'address' => 'nullable|string|max:255',
                    'company_name' => 'nullable|string|max:255',
                    'registration_type' => 'required|in:onsite,online,pre-registered',
                    'payment_status' => 'nullable|in:unpaid,paid',
                ]);
                
                // Update the email_hash if the email has changed
                if ($registration->email !== $validated['email']) {
                    $validated['email_hash'] = hash('sha256', strtolower(trim($validated['email'])));
                }
                
                // The model's accessors/mutators will handle encryption automatically
                $registration->update($validated);
                
                return response()->json($registration->fresh());
            }

        /**
         * Delete a registration.
         */
        public function destroy(Registration $registration)
            {
                $registration->delete();
            
                return response()->json(null, 204); // 204 No Content success response
            }
        public function scan(Request $request, ?string $ticket_number = null): JsonResponse
            {
                // Accept from route param or request body
                $ticket = $ticket_number ?: $request->input('ticket_number');
                if (!$ticket) {
                    return response()->json(['error' => 'ticket_number is required'], 422);
                }
            
                $registration = Registration::where('ticket_number', $ticket)->firstOrFail();
                $currentMode = ServerMode::latest()->first()->mode ?? 'onsite';
            
                if ($registration->server_mode !== $currentMode && $currentMode !== 'both') {
                    return response()->json(['error' => 'Scan not allowed in current mode'], 403);
                }
            
                // Superadmin can reprint unlimited
                $isSuperAdmin = optional($request->user()->role)->name === 'superadmin';
            
                // --- Statuses ---
                $badgeQueued     = PrintStatus::where('type', 'badge')->where('name', 'queued')->first();
                $badgePrinting   = PrintStatus::where('type', 'badge')->where('name', 'printing')->first();
                $badgePrinted    = PrintStatus::where('type', 'badge')->where('name', 'printed')->first();
                $badgeReprinted  = PrintStatus::where('type', 'badge')->where('name', 'reprinted')->first();
            
                $ticketQueued    = PrintStatus::where('type', 'ticket')->where('name', 'queued')->first();
                $ticketPrinting  = PrintStatus::where('type', 'ticket')->where('name', 'printing')->first();
                $ticketPrinted   = PrintStatus::where('type', 'ticket')->where('name', 'printed')->first();
                $ticketReprinted = PrintStatus::where('type', 'ticket')->where('name', 'reprinted')->first();
            
                if (!$badgeQueued || !$badgePrinting || !$badgePrinted || !$badgeReprinted ||
                    !$ticketQueued || !$ticketPrinting || !$ticketPrinted || !$ticketReprinted) {
                    return response()->json(['error' => 'Print statuses not configured'], 400);
                }
            
                // --- Create scan log ---
                $scan = Scan::create([
                    'registration_id' => $registration->id,
                    'scanned_by' => Auth::id(),
                    'scanned_time' => now(),
                    'badge_printed_status_id' => $badgeQueued->id,
                    'ticket_printed_status_id' => $ticketQueued->id,
                    'payment_status' => $registration->payment_status->id,
                ]);
            
                // --- Auto confirm if not already ---
                if (!$registration->confirmed) {
                    $registration->update([
                        'confirmed' => true,
                        'confirmed_by' => Auth::id(),
                        'confirmed_at' => now(),
                    ]);
                }
            
                // --- Badge flow with one-time reprint limit (superadmin bypass) ---
                $badgeStatusId = $registration->badge_printed_status_id;
                if ($badgeStatusId === $badgeReprinted->id) {
                    if (!$isSuperAdmin) {
                        return response()->json(['error' => 'Badge already reprinted once. Reprint limit reached.'], 409);
                    }
                    // superadmin: allow additional prints; keep status as "reprinted"
                    // no change needed
                } elseif ($badgeStatusId === $badgePrinted->id) {
                    // printed → reprinted
                    $registration->update(['badge_printed_status_id' => $badgeReprinted->id]);
                } else {
                    // not_printed (or other) → queue → printing → printed
                    $registration->update(['badge_printed_status_id' => $badgeQueued->id]);
                    $registration->update(['badge_printed_status_id' => $badgePrinting->id]);
                    $registration->update(['badge_printed_status_id' => $badgePrinted->id]);
                }
            
                // --- Ticket flow (mirror; optional to enforce limit the same way) ---
                $ticketStatusId = $registration->ticket_printed_status_id;
                if ($ticketStatusId === $ticketReprinted->id) {
                    if ($isSuperAdmin) {
                        // allow; keep as reprinted
                    } else {
                        // If you want the same strict limit for tickets, uncomment:
                        // return response()->json(['error' => 'Ticket already reprinted once. Reprint limit reached.'], 409);
                    }
                } elseif ($ticketStatusId === $ticketPrinted->id) {
                    $registration->update(['ticket_printed_status_id' => $ticketReprinted->id]);
                } else {
                    $registration->update(['ticket_printed_status_id' => $ticketQueued->id]);
                    $registration->update(['ticket_printed_status_id' => $ticketPrinting->id]);
                    $registration->update(['ticket_printed_status_id' => $ticketPrinted->id]);
                }
            
                Log::info('Registration scanned; statuses updated', [
                    'ticket_number' => $ticket,
                    'user_id' => Auth::id(),
                    'mode' => $currentMode,
                    'superadmin_bypass' => $isSuperAdmin,
                ]);
            
                return response()->json([
                    'message' => 'Scanned. Print statuses updated (printed/reprinted).',
                    'scan' => $scan,
                    'registration' => $registration->fresh(),
                ], 200);
            }

            public function printBadge($ticketNumber): JsonResponse
            {
                $registration = Registration::where('ticket_number', $ticketNumber)->firstOrFail();
            
                $badgeQueued = PrintStatus::where('type', 'badge')->where('name', 'queued')->first();
                $badgePrinting = PrintStatus::where('type', 'badge')->where('name', 'printing')->first();
                $badgePrinted = PrintStatus::where('type', 'badge')->where('name', 'printed')->first();
                $badgeFailed = PrintStatus::where('type', 'badge')->where('name', 'failed')->first();
            
                if (!$badgeQueued || !$badgePrinting || !$badgePrinted) {
                    return response()->json(['error' => 'Badge print statuses not configured'], 400);
                }
            
                // Transition to queued
                $registration->update(['badge_printed_status_id' => $badgeQueued->id]);
                Log::info('Badge print queued', ['ticket_number' => $ticketNumber]);
            
                try {
                    // Transition to printing
                    $registration->update(['badge_printed_status_id' => $badgePrinting->id]);
            
                    // 🚀 Simulate actual print job here (dispatch to printer)
                    // If successful → mark printed
                    $registration->update(['badge_printed_status_id' => $badgePrinted->id]);
            
                    Log::info('Badge printed', ['ticket_number' => $ticketNumber, 'user_id' => Auth::id()]);
                    return response()->json([
                        'message' => 'Badge marked as printed',
                        'registration' => $registration->fresh(),
                    ], 200);
            
                } catch (\Exception $e) {
                    if ($badgeFailed) {
                        $registration->update(['badge_printed_status_id' => $badgeFailed->id]);
                    }
                    Log::error('Badge printing failed', ['ticket_number' => $ticketNumber, 'error' => $e->getMessage()]);
                    return response()->json(['error' => 'Failed to print badge'], 500);
                }
            }

            public function printTicket($ticketNumber): JsonResponse
            {
                $registration = Registration::where('ticket_number', $ticketNumber)->firstOrFail();
            
                $ticketQueued = PrintStatus::where('type', 'ticket')->where('name', 'queued')->first();
                $ticketPrinting = PrintStatus::where('type', 'ticket')->where('name', 'printing')->first();
                $ticketPrinted = PrintStatus::where('type', 'ticket')->where('name', 'printed')->first();
                $ticketFailed = PrintStatus::where('type', 'ticket')->where('name', 'failed')->first();
            
                if (!$ticketQueued || !$ticketPrinting || !$ticketPrinted) {
                    return response()->json(['error' => 'Ticket print statuses not configured'], 400);
                }
            
                // Transition to queued
                $registration->update(['ticket_printed_status_id' => $ticketQueued->id]);
                Log::info('Ticket print queued', ['ticket_number' => $ticketNumber]);
            
                try {
                    // Transition to printing
                    $registration->update(['ticket_printed_status_id' => $ticketPrinting->id]);
                
                    // 🚀 Simulate actual print job here (dispatch to printer)
                    $registration->update(['ticket_printed_status_id' => $ticketPrinted->id]);
                
                    Log::info('Ticket printed', ['ticket_number' => $ticketNumber, 'user_id' => Auth::id()]);
                    return response()->json([
                        'message' => 'Ticket marked as printed',
                        'registration' => $registration->fresh(),
                    ], 200);
                
                } catch (\Exception $e) {
                    if ($ticketFailed) {
                        $registration->update(['ticket_printed_status_id' => $ticketFailed->id]);
                    }
                    Log::error('Ticket printing failed', ['ticket_number' => $ticketNumber, 'error' => $e->getMessage()]);
                    return response()->json(['error' => 'Failed to print ticket'], 500);
                }
            } 

             /**
     * Unified: Scan QR + Auto print Badge
     */
    public function scanAndPrintBadge($ticketNumber): JsonResponse
    {
        $registration = Registration::where('ticket_number', $ticketNumber)->firstOrFail();

        $badgeQueued   = PrintStatus::where('type', 'badge')->where('name', 'queued')->first();
        $badgePrinting = PrintStatus::where('type', 'badge')->where('name', 'printing')->first();
        $badgePrinted  = PrintStatus::where('type', 'badge')->where('name', 'printed')->first();
        $badgeReprinted= PrintStatus::where('type', 'badge')->where('name', 'reprinted')->first();
        $badgeFailed   = PrintStatus::where('type', 'badge')->where('name', 'failed')->first();

        if (!$badgeQueued || !$badgePrinting || !$badgePrinted) {
            return response()->json(['error' => 'Badge print statuses not configured'], 400);
        }

        // --- Create scan log
        $scan = Scan::create([
            'registration_id' => $registration->id,
            'scanned_by' => Auth::id(),
            'scanned_time' => now(),
            'badge_printed_status_id' => $badgeQueued->id,
        ]);

        try {
            // If already printed → mark as reprinted
            if ($registration->badge_printed_status_id == $badgePrinted->id) {
                $registration->update(['badge_printed_status_id' => $badgeReprinted->id]);
            } else {
                $registration->update(['badge_printed_status_id' => $badgeQueued->id]);
                $registration->update(['badge_printed_status_id' => $badgePrinting->id]);

                // 🚀 Simulate print here
                $registration->update(['badge_printed_status_id' => $badgePrinted->id]);
            }

            Log::info('Scan + badge print complete', [
                'ticket_number' => $ticketNumber,
                'user_id' => Auth::id()
            ]);

            return response()->json([
                'message' => 'Scanned → Badge printed',
                'scan' => $scan,
                'registration' => $registration->fresh(),
            ], 200);

        } catch (\Exception $e) {
            if ($badgeFailed) {
                $registration->update(['badge_printed_status_id' => $badgeFailed->id]);
            }
            Log::error('Badge printing failed after scan', [
                'ticket_number' => $ticketNumber,
                'error' => $e->getMessage()
            ]);
            return response()->json(['error' => 'Failed to print badge after scan'], 500);
        }
    }

    /**
     * Unified: Scan QR + Auto print Ticket
     */
    public function scanAndPrintTicket($ticketNumber): JsonResponse
    {
        $registration = Registration::where('ticket_number', $ticketNumber)->firstOrFail();

        $ticketQueued   = PrintStatus::where('type', 'ticket')->where('name', 'queued')->first();
        $ticketPrinting = PrintStatus::where('type', 'ticket')->where('name', 'printing')->first();
        $ticketPrinted  = PrintStatus::where('type', 'ticket')->where('name', 'printed')->first();
        $ticketReprinted= PrintStatus::where('type', 'ticket')->where('name', 'reprinted')->first();
        $ticketFailed   = PrintStatus::where('type', 'ticket')->where('name', 'failed')->first();

        if (!$ticketQueued || !$ticketPrinting || !$ticketPrinted) {
            return response()->json(['error' => 'Ticket print statuses not configured'], 400);
        }

        // --- Create scan log
        $scan = Scan::create([
            'registration_id' => $registration->id,
            'scanned_by' => Auth::id(),
            'scanned_time' => now(),
            'ticket_printed_status_id' => $ticketQueued->id,
        ]);

        try {
            // If already printed → mark as reprinted
            if ($registration->ticket_printed_status_id == $ticketPrinted->id) {
                $registration->update(['ticket_printed_status_id' => $ticketReprinted->id]);
            } else {
                $registration->update(['ticket_printed_status_id' => $ticketQueued->id]);
                $registration->update(['ticket_printed_status_id' => $ticketPrinting->id]);

                // 🚀 Simulate print here
                $registration->update(['ticket_printed_status_id' => $ticketPrinted->id]);
            }

            Log::info('Scan + ticket print complete', [
                'ticket_number' => $ticketNumber,
                'user_id' => Auth::id()
            ]);

            return response()->json([
                'message' => 'Scanned → Ticket printed',
                'scan' => $scan,
                'registration' => $registration->fresh(),
            ], 200);

        } catch (\Exception $e) {
            if ($ticketFailed) {
                $registration->update(['ticket_printed_status_id' => $ticketFailed->id]);
            }
            Log::error('Ticket printing failed after scan', [
                'ticket_number' => $ticketNumber,
                'error' => $e->getMessage()
            ]);
            return response()->json(['error' => 'Failed to print ticket after scan'], 500);
        }
    }
} 







 
