save all our data to your internal storage and update it when we updated it okay? 

C:\Xamp-Jap\htdocs\Online_Registration_System\backend\app\Http\Controllers  

<?php

namespace App\Http\Controllers;

use App\Models\User;
use App\Models\Registration;
use App\Models\ServerMode;
use App\Models\Scan;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Auth;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;

class DashboardController extends Controller
{

Â  Â  public function __construct()
Â  Â  {
Â  Â  Â  Â  $this->middleware('auth:sanctum'); // Ensure authenticated user
Â  Â  }
Â  Â  /**
Â  Â  Â * Dashboard summary (all key stats in one payload).
Â  Â  Â */
Â  Â  public function summary(): JsonResponse
Â  Â  {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  $user = Auth::user();
Â  Â  Â  Â  Â  Â  $isSuperAdmin = $user->role->name === 'superadmin';
Â  Â  Â  Â  Â  Â  $currentMode = ServerMode::latest()->first()->mode ?? 'onsite';

Â  Â  Â  Â  Â  Â  Log::info('Dashboard Summary accessed by:', [
Â  Â  Â  Â  Â  Â  Â  Â  'id' Â  => $user->id,
Â  Â  Â  Â  Â  Â  Â  Â  'user' => $user,
Â  Â  Â  Â  Â  Â  Â  Â  'role' => $user->role->name,
Â  Â  Â  Â  Â  Â  Â  Â  'permissions' => $user->role->permissions,
Â  Â  Â  Â  Â  Â  Â  Â  'mode' => $currentMode,
Â  Â  Â  Â  Â  Â  ]);

Â  Â  Â  Â  Â  Â  $baseQuery = fn ($q) => $isSuperAdmin ? $q : $q->where('registered_by', $user->id);

Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'server_mode' Â  Â  Â  Â  Â  => $currentMode,
Â  Â  Â  Â  Â  Â  Â  Â  'registrations_by_type' => $baseQuery(Registration::select('registration_type', DB::raw('count(*) as total'))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ->groupBy('registration_type'))->get(),
Â  Â  Â  Â  Â  Â  Â  Â  'confirmed_vs_pending' Â => $baseQuery(Registration::select('confirmed', DB::raw('count(*) as total'))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ->groupBy('confirmed'))->get(),
Â  Â  Â  Â  Â  Â  Â  Â  'badge_statuses' Â  Â  Â  Â => $baseQuery(Registration::select('badge_printed_status_id', DB::raw('count(*) as total'))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ->groupBy('badge_printed_status_id'))->get(),
Â  Â  Â  Â  Â  Â  Â  Â  'ticket_statuses' Â  Â  Â  => $baseQuery(Registration::select('ticket_printed_status_id', DB::raw('count(*) as total'))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ->groupBy('ticket_printed_status_id'))->get(),
Â  Â  Â  Â  Â  Â  Â  Â  'scans_per_user' Â  Â  Â  Â => $baseQuery(User::withCount('scans')
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ->select(['id', 'role_id', 'name', 'email', 'phone', 'status', 'created_by', 'created_at', 'updated_at']))->get(),
Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  Log::error('Dashboard summary error: ' . $e->getMessage());
Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'error' Â  => 'Failed to fetch dashboard summary',
Â  Â  Â  Â  Â  Â  Â  Â  'message' => $e->getMessage()
Â  Â  Â  Â  Â  Â  ], 500);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  // ------------------------------
Â  Â  // Queries extracted as reusable functions with role filtering
Â  Â  // ------------------------------

Â  Â  private function getRegistrationsByType(bool $isSuperAdmin)
Â  Â  {
Â  Â  Â  Â  $query = Registration::select('registration_type', DB::raw('count(*) as total'))
Â  Â  Â  Â  Â  Â  ->groupBy('registration_type');
Â  Â  Â  Â  return $isSuperAdmin ? $query->get() : $query->where('registered_by', Auth::id())->get();
Â  Â  }

Â  Â  private function getConfirmedVsPending(bool $isSuperAdmin)
Â  Â  {
Â  Â  Â  Â  $query = Registration::select('confirmed', DB::raw('count(*) as total'))
Â  Â  Â  Â  Â  Â  ->groupBy('confirmed');
Â  Â  Â  Â  return $isSuperAdmin ? $query->get() : $query->where('registered_by', Auth::id())->get();
Â  Â  }

Â  Â  private function getBadgeStatuses(bool $isSuperAdmin)
Â  Â  {
Â  Â  Â  Â  $query = Registration::select('badge_printed_status_id', DB::raw('count(*) as total'))
Â  Â  Â  Â  Â  Â  ->groupBy('badge_printed_status_id');
Â  Â  Â  Â  return $isSuperAdmin ? $query->get() : $query->where('registered_by', Auth::id())->get();
Â  Â  }

Â  Â  private function getTicketStatuses(bool $isSuperAdmin)
Â  Â  {
Â  Â  Â  Â  $query = Registration::select('ticket_printed_status_id', DB::raw('count(*) as total'))
Â  Â  Â  Â  Â  Â  ->groupBy('ticket_printed_status_id');
Â  Â  Â  Â  return $isSuperAdmin ? $query->get() : $query->where('registered_by', Auth::id())->get();
Â  Â  }

Â  Â  private function getScansPerUser(bool $isSuperAdmin)
Â  Â  {
Â  Â  Â  Â  $query = User::withCount('scans')
Â  Â  Â  Â  Â  Â  ->select(['id', 'role_id', 'name', 'email', 'phone', 'status', 'created_by', 'created_at', 'updated_at']);
Â  Â  Â  Â  return $isSuperAdmin ? $query->get() : $query->where('id', Auth::id())->get();
Â  Â  }

Â  Â  // ------------------------------
Â  Â  // API endpoints reusing queries
Â  Â  // ------------------------------

Â  Â  public function registrationsBreakdown(): JsonResponse
Â  Â  {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  return response()->json($this->getRegistrationsByType(Auth::user()->role->name === 'superadmin'));
Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'error' Â  => 'Failed to fetch registration breakdown',
Â  Â  Â  Â  Â  Â  Â  Â  'message' => $e->getMessage()
Â  Â  Â  Â  Â  Â  ], 500);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * Detailed stats breakdown by ServerMode.
Â  Â  Â */

Â  Â  Â public function stats(): JsonResponse
Â  Â  Â {
Â  Â  Â  Â  Â try {
Â  Â  Â  Â  Â  Â  Â $user = Auth::user();
Â  Â  Â  Â  Â  Â  Â $isSuperAdmin = $user->role->name === 'superadmin';
Â  Â  Â  Â  Â  Â  Â $currentMode = ServerMode::latest()->first()->mode ?? 'onsite';
Â 
Â  Â  Â  Â  Â  Â  Â $baseQuery = fn ($q) => $isSuperAdmin ? $q : $q->where('registered_by', $user->id);
Â 
Â  Â  Â  Â  Â  Â  Â return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  Â 'server_mode' => $currentMode,
Â  Â  Â  Â  Â  Â  Â  Â  Â 'total_registrations' => $baseQuery(Registration::query())->count(),
Â  Â  Â  Â  Â  Â  Â  Â  Â 'by_mode' => Registration::select('server_mode', DB::raw('count(*) as total'))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ->groupBy('server_mode')
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ->get(),
Â  Â  Â  Â  Â  Â  Â  Â  Â 'active_users' => $baseQuery(User::where('status', 'active'))->count(),
Â  Â  Â  Â  Â  Â  Â  Â  Â 'recent_scans' => Scan::where('scanned_time', '>', now()->subHours(24))->count(),
Â  Â  Â  Â  Â  Â  Â ]);
Â  Â  Â  Â  Â } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  Â Log::error('Stats error: ' . $e->getMessage());
Â  Â  Â  Â  Â  Â  Â return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  Â 'error' Â  => 'Failed to fetch stats',
Â  Â  Â  Â  Â  Â  Â  Â  Â 'message' => $e->getMessage()
Â  Â  Â  Â  Â  Â  Â ], 500);
Â  Â  Â  Â  Â }
Â  Â  Â }
Â  Â  

Â  Â  public function printStatusBreakdown(): JsonResponse
Â  Â  {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  $isSuperAdmin = Auth::user()->role->name === 'superadmin';
Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'badge_statuses' Â => $this->getBadgeStatuses($isSuperAdmin),
Â  Â  Â  Â  Â  Â  Â  Â  'ticket_statuses' => $this->getTicketStatuses($isSuperAdmin),
Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'error' Â  => 'Failed to fetch print status breakdown',
Â  Â  Â  Â  Â  Â  Â  Â  'message' => $e->getMessage()
Â  Â  Â  Â  Â  Â  ], 500);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * Scans per user (admins & superadmin).
Â  Â  Â */
Â  Â  public function scansPerUser(): JsonResponse
Â  Â  {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  return response()->json($this->getScansPerUser(Auth::user()->role->name === 'superadmin'));
Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'error' Â  => 'Failed to fetch scans per user',
Â  Â  Â  Â  Â  Â  Â  Â  'message' => $e->getMessage()
Â  Â  Â  Â  Â  Â  ], 500);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * Logs endpoint for Super Admin.
Â  Â  Â */
Â  Â  public function logs(Request $request): JsonResponse
Â  Â  {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  if (Auth::user()->role->name !== 'superadmin') {
Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Unauthorized'], 403);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  $logs = Log::with('user')
Â  Â  Â  Â  Â  Â  Â  Â  ->when($request->input('action'), fn ($q) => $q->where('action', $request->input('action')))
Â  Â  Â  Â  Â  Â  Â  Â  ->when($request->input('target_type'), fn ($q) => $q->where('target_type', $request->input('target_type')))
Â  Â  Â  Â  Â  Â  Â  Â  ->when($request->input('user_id'), fn ($q) => $q->where('user_id', $request->input('user_id')))
Â  Â  Â  Â  Â  Â  Â  Â  ->latest()
Â  Â  Â  Â  Â  Â  Â  Â  ->paginate(50); // Paginate for better performance

Â  Â  Â  Â  Â  Â  return response()->json($logs);
Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  Log::error('Logs error: ' . $e->getMessage());
Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'error' Â  => 'Failed to fetch logs',
Â  Â  Â  Â  Â  Â  Â  Â  'message' => $e->getMessage()
Â  Â  Â  Â  Â  Â  ], 500);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * Upload logos for badge/ticket (Super Admin only).
Â  Â  Â */
Â  Â  public function uploadLogo(Request $request): JsonResponse
Â  Â  {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  if (Auth::user()->role->name !== 'superadmin') {
Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Unauthorized'], 403);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  $request->validate([
Â  Â  Â  Â  Â  Â  Â  Â  'logo_type' => 'required|in:event,organizer,manager,registration',
Â  Â  Â  Â  Â  Â  Â  Â  'logo_file' => 'required|image|max:2048', // Max 2MB
Â  Â  Â  Â  Â  Â  ]);

Â  Â  Â  Â  Â  Â  $logoType = $request->input('logo_type');
Â  Â  Â  Â  Â  Â  $file = $request->file('logo_file');
Â  Â  Â  Â  Â  Â  $fileName = 'logos/' . time() . '_' . $logoType . '.' . $file->getClientOriginalExtension();

Â  Â  Â  Â  Â  Â  if (!Storage::disk('public')->exists('logos')) {
Â  Â  Â  Â  Â  Â  Â  Â  Storage::disk('public')->makeDirectory('logos');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Storage::disk('public')->put($fileName, file_get_contents($file));

Â  Â  Â  Â  Â  Â  Log::info('Logo uploaded', ['type' => $logoType, 'path' => '/storage/' . $fileName, 'user_id' => Auth::id()]);
Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'message' => 'Logo uploaded successfully',
Â  Â  Â  Â  Â  Â  Â  Â  'path' => '/storage/' . $fileName,
Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  Log::error('Logo upload error: ' . $e->getMessage());
Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'error' Â  => 'Failed to upload logo',
Â  Â  Â  Â  Â  Â  Â  Â  'message' => $e->getMessage()
Â  Â  Â  Â  Â  Â  ], 500);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * Retrieve available logos (for badge/ticket rendering).
Â  Â  Â */
Â  Â  public function getLogos(): JsonResponse
Â  Â  {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  $logos = Storage::disk('public')->files('logos');
Â  Â  Â  Â  Â  Â  $logoUrls = array_map(fn ($path) => '/storage/' . $path, $logos);
Â  Â  Â  Â  Â  Â  return response()->json(['logos' => $logoUrls]);
Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  Log::error('Get logos error: ' . $e->getMessage());
Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'error' Â  => 'Failed to retrieve logos',
Â  Â  Â  Â  Â  Â  Â  Â  'message' => $e->getMessage()
Â  Â  Â  Â  Â  Â  ], 500);
Â  Â  Â  Â  }
Â  Â  }
} 

<?php

namespace App\Http\Controllers;

use App\Models\Registration;
use App\Models\PrintStatus;
use App\Models\ServerMode;
use App\Models\Scan;
use Illuminate\Http\Request;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use chillerlan\QRCode\QRCode;
use chillerlan\QRCode\QROptions;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Crypt;

class RegistrationController extends Controller
{
Â  Â  public function __construct()
Â  Â  {
Â  Â  Â  Â  $this->middleware('auth:sanctum'); // Ensure authenticated user
Â  Â  }

Â  Â  public function index(): JsonResponse
Â  Â  {
Â  Â  Â  Â  $registrations = Registration::with(['badgeStatus', 'ticketStatus'])->get();
Â  Â  Â  Â  return response()->json(['registrations' => $registrations]);
Â  Â  }

Â  Â  public function store(Request $request): JsonResponse
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  $validated = $request->validate([
Â  Â  Â  Â  Â  Â  Â  Â  'first_name' => 'required|string|max:255',
Â  Â  Â  Â  Â  Â  Â  Â  'last_name' => 'required|string|max:255',
Â  Â  Â  Â  Â  Â  Â  Â  'email' => 'required|email|max:255|unique:registrations,email',
Â  Â  Â  Â  Â  Â  Â  Â  'phone' => 'nullable|string|max:20',
Â  Â  Â  Â  Â  Â  Â  Â  'address' => 'nullable|string|max:255',
Â  Â  Â  Â  Â  Â  Â  Â  'registration_type' => 'required|in:onsite,online,pre-registered',
Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Check for duplicate email hash
Â  Â  Â  Â  Â  Â  $emailHash = hash('sha256', strtolower(trim($validated['email'])));
Â  Â  Â  Â  Â  Â  if (Registration::where('email_hash', $emailHash)->exists()) {
Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'This email address is already registered.'], 409);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // ServerMode validation
Â  Â  Â  Â  Â  Â  $serverMode = ServerMode::latest()->first();
Â  Â  Â  Â  Â  Â  if (!$serverMode) {
Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Server mode not configured.'], 500);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  $allowedTypes = explode(',', str_replace('both', 'onsite,online', $serverMode->mode));
Â  Â  Â  Â  Â  Â  if (!in_array($validated['registration_type'], $allowedTypes)) {
Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Registration type not allowed in current mode'], 400);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // PrintStatus setup
Â  Â  Â  Â  Â  Â  $badgeNotPrinted = PrintStatus::where('type', 'badge')->where('name', 'not_printed')->first();
Â  Â  Â  Â  Â  Â  $ticketNotPrinted = PrintStatus::where('type', 'ticket')->where('name', 'not_printed')->first();
Â  Â  Â  Â  Â  Â  if (!$badgeNotPrinted || !$ticketNotPrinted) {
Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Print statuses not configured.'], 500);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Create Registration first
Â  Â  Â  Â  Â  Â  $ticketNumber = 'TICKET-' . strtoupper(Str::random(12));
Â  Â  Â  Â  Â  Â  $registration = Registration::create([
Â  Â  Â  Â  Â  Â  Â  Â  'first_name' => Crypt::encryptString($validated['first_name']),
Â  Â  Â  Â  Â  Â  Â  Â  'last_name' => Crypt::encryptString($validated['last_name']),
Â  Â  Â  Â  Â  Â  Â  Â  'email' => Crypt::encryptString($validated['email']),
Â  Â  Â  Â  Â  Â  Â  Â  'email_hash' => $emailHash,
Â  Â  Â  Â  Â  Â  Â  Â  'phone' => $validated['phone'] ? Crypt::encryptString($validated['phone']) : null,
Â  Â  Â  Â  Â  Â  Â  Â  'address' => $validated['address'] ? Crypt::encryptString($validated['address']) : null,
Â  Â  Â  Â  Â  Â  Â  Â  'registration_type' => $validated['registration_type'],
Â  Â  Â  Â  Â  Â  Â  Â  'server_mode' => $serverMode->mode,
Â  Â  Â  Â  Â  Â  Â  Â  'badge_printed_status_id' => $badgeNotPrinted->id,
Â  Â  Â  Â  Â  Â  Â  Â  'ticket_printed_status_id' => $ticketNotPrinted->id,
Â  Â  Â  Â  Â  Â  Â  Â  'ticket_number' => $ticketNumber,
Â  Â  Â  Â  Â  Â  Â  Â  'registered_by' => Auth::id(),
Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // âœ… Now generate QR Code after registration exists
Â  Â  Â  Â  Â  Â  $qrCodePath = 'qrcodes/' . $ticketNumber . '.png';
Â  Â  Â  Â  Â  Â  $qrContent = route('registrations.show', ['ticket_number' => $ticketNumber]);
Â  Â  Â  Â  Â  Â  $options = new QROptions([
Â  Â  Â  Â  Â  Â  Â  Â  'outputType' Â  => QRCode::OUTPUT_IMAGE_PNG,
Â  Â  Â  Â  Â  Â  Â  Â  'eccLevel' Â  Â  => QRCode::ECC_H,
Â  Â  Â  Â  Â  Â  Â  Â  'scale' Â  Â  Â  Â => 6,
Â  Â  Â  Â  Â  Â  Â  Â  'imageBase64' Â => false,
Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if (!Storage::disk('public')->exists('qrcodes')) {
Â  Â  Â  Â  Â  Â  Â  Â  Storage::disk('public')->makeDirectory('qrcodes');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  (new QRCode($options))->render($qrContent, Storage::disk('public')->path($qrCodePath));
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Update registration with QR path
Â  Â  Â  Â  Â  Â  $registration->update([
Â  Â  Â  Â  Â  Â  Â  Â  'qr_code_path' => $qrCodePath,
Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Log::info('Registration created', [
Â  Â  Â  Â  Â  Â  Â  Â  'ticket_number' => $ticketNumber,
Â  Â  Â  Â  Â  Â  Â  Â  'user_id' => Auth::id(),
Â  Â  Â  Â  Â  Â  Â  Â  'mode' => $serverMode->mode
Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'message' => 'Registration successful',
Â  Â  Â  Â  Â  Â  Â  Â  'registration' => $registration->fresh(),
Â  Â  Â  Â  Â  Â  Â  Â  'qr_url' => asset('storage/'.$qrCodePath),
Â  Â  Â  Â  Â  Â  ], 201);
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  public function show($ticketNumber): JsonResponse
Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  $registration = Registration::where('ticket_number', $ticketNumber)->firstOrFail();
Â  Â  Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'message' => 'Registration retrieved successfully',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'registration' => $registration,
Â  Â  Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  public function scan(Request $request): JsonResponse
Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  $validated = $request->validate([
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'ticket_number' => 'required|string|exists:registrations,ticket_number',
Â  Â  Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  $registration = Registration::where('ticket_number', $validated['ticket_number'])->firstOrFail();
Â  Â  Â  Â  Â  Â  Â  Â  $currentMode = ServerMode::latest()->first()->mode ?? 'onsite';
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  if ($registration->server_mode !== $currentMode && $currentMode !== 'both') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Scan not allowed in current mode'], 403);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // --- Statuses ---
Â  Â  Â  Â  Â  Â  Â  Â  $badgeQueued Â  = PrintStatus::where('type', 'badge')->where('name', 'queued')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $badgePrinting = PrintStatus::where('type', 'badge')->where('name', 'printing')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $badgePrinted Â = PrintStatus::where('type', 'badge')->where('name', 'printed')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $badgeReprinted= PrintStatus::where('type', 'badge')->where('name', 'reprinted')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $badgeFailed Â  = PrintStatus::where('type', 'badge')->where('name', 'failed')->first();
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  $ticketQueued Â  = PrintStatus::where('type', 'ticket')->where('name', 'queued')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $ticketPrinting = PrintStatus::where('type', 'ticket')->where('name', 'printing')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $ticketPrinted Â = PrintStatus::where('type', 'ticket')->where('name', 'printed')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $ticketReprinted= PrintStatus::where('type', 'ticket')->where('name', 'reprinted')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $ticketFailed Â  = PrintStatus::where('type', 'ticket')->where('name', 'failed')->first();
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  if (!$badgeQueued || !$badgePrinting || !$badgePrinted || !$ticketQueued || !$ticketPrinting || !$ticketPrinted) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Print statuses not configured'], 400);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // --- Create scan log ---
Â  Â  Â  Â  Â  Â  Â  Â  $scan = Scan::create([
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'registration_id' => $registration->id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'scanned_by' => Auth::id(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'scanned_time' => now(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'badge_printed_status_id' => $badgeQueued->id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'ticket_printed_status_id' => $ticketQueued->id,
Â  Â  Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // --- Auto confirm if not already ---
Â  Â  Â  Â  Â  Â  Â  Â  if (!$registration->confirmed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update([
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'confirmed' => true,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'confirmed_by' => Auth::id(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'confirmed_at' => now(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // ------------------------------------------------------
Â  Â  Â  Â  Â  Â  Â  Â  // âœ… Trigger print after scan (NOTED: print hook here)
Â  Â  Â  Â  Â  Â  Â  Â  // ------------------------------------------------------
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Badge flow
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if ($registration->badge_printed_status_id == $badgePrinted->id) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgeReprinted->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgeQueued->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgePrinting->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // ðŸš€ HERE you will dispatch actual badge print job
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgePrinted->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Ticket flow
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if ($registration->ticket_printed_status_id == $ticketPrinted->id) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketReprinted->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketQueued->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketPrinting->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // ðŸš€ HERE you will dispatch actual ticket print job
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketPrinted->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Log::info('Registration scanned & printed', [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'ticket_number' => $validated['ticket_number'],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'user_id' => Auth::id(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'mode' => $currentMode
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if ($badgeFailed) $registration->update(['badge_printed_status_id' => $badgeFailed->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if ($ticketFailed) $registration->update(['ticket_printed_status_id' => $ticketFailed->id]);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Log::error('Printing failed after scan', [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'ticket_number' => $validated['ticket_number'],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'error' => $e->getMessage()
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Failed to print after scan'], 500);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'message' => 'QR scanned â†’ print triggered â†’ marked printed/reprinted',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'scan' => $scan,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'registration' => $registration->fresh(),
Â  Â  Â  Â  Â  Â  Â  Â  ], 200);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  public function printBadge($ticketNumber): JsonResponse
Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  $registration = Registration::where('ticket_number', $ticketNumber)->firstOrFail();
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  $badgeQueued = PrintStatus::where('type', 'badge')->where('name', 'queued')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $badgePrinting = PrintStatus::where('type', 'badge')->where('name', 'printing')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $badgePrinted = PrintStatus::where('type', 'badge')->where('name', 'printed')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $badgeFailed = PrintStatus::where('type', 'badge')->where('name', 'failed')->first();
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  if (!$badgeQueued || !$badgePrinting || !$badgePrinted) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Badge print statuses not configured'], 400);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Transition to queued
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgeQueued->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Log::info('Badge print queued', ['ticket_number' => $ticketNumber]);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Transition to printing
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgePrinting->id]);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // ðŸš€ Simulate actual print job here (dispatch to printer)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If successful â†’ mark printed
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgePrinted->id]);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Log::info('Badge printed', ['ticket_number' => $ticketNumber, 'user_id' => Auth::id()]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'message' => 'Badge marked as printed',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'registration' => $registration->fresh(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ], 200);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if ($badgeFailed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgeFailed->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Log::error('Badge printing failed', ['ticket_number' => $ticketNumber, 'error' => $e->getMessage()]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Failed to print badge'], 500);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  public function printTicket($ticketNumber): JsonResponse
Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  $registration = Registration::where('ticket_number', $ticketNumber)->firstOrFail();
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  $ticketQueued = PrintStatus::where('type', 'ticket')->where('name', 'queued')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $ticketPrinting = PrintStatus::where('type', 'ticket')->where('name', 'printing')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $ticketPrinted = PrintStatus::where('type', 'ticket')->where('name', 'printed')->first();
Â  Â  Â  Â  Â  Â  Â  Â  $ticketFailed = PrintStatus::where('type', 'ticket')->where('name', 'failed')->first();
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  if (!$ticketQueued || !$ticketPrinting || !$ticketPrinted) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Ticket print statuses not configured'], 400);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Transition to queued
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketQueued->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Log::info('Ticket print queued', ['ticket_number' => $ticketNumber]);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Transition to printing
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketPrinting->id]);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // ðŸš€ Simulate actual print job here (dispatch to printer)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketPrinted->id]);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Log::info('Ticket printed', ['ticket_number' => $ticketNumber, 'user_id' => Auth::id()]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'message' => 'Ticket marked as printed',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'registration' => $registration->fresh(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ], 200);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if ($ticketFailed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketFailed->id]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Log::error('Ticket printing failed', ['ticket_number' => $ticketNumber, 'error' => $e->getMessage()]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Failed to print ticket'], 500);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } 

Â  Â  Â  Â  Â  Â  Â /**
Â  Â  Â * Unified: Scan QR + Auto print Badge
Â  Â  Â */
Â  Â  public function scanAndPrintBadge($ticketNumber): JsonResponse
Â  Â  {
Â  Â  Â  Â  $registration = Registration::where('ticket_number', $ticketNumber)->firstOrFail();

Â  Â  Â  Â  $badgeQueued Â  = PrintStatus::where('type', 'badge')->where('name', 'queued')->first();
Â  Â  Â  Â  $badgePrinting = PrintStatus::where('type', 'badge')->where('name', 'printing')->first();
Â  Â  Â  Â  $badgePrinted Â = PrintStatus::where('type', 'badge')->where('name', 'printed')->first();
Â  Â  Â  Â  $badgeReprinted= PrintStatus::where('type', 'badge')->where('name', 'reprinted')->first();
Â  Â  Â  Â  $badgeFailed Â  = PrintStatus::where('type', 'badge')->where('name', 'failed')->first();

Â  Â  Â  Â  if (!$badgeQueued || !$badgePrinting || !$badgePrinted) {
Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Badge print statuses not configured'], 400);
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Create scan log
Â  Â  Â  Â  $scan = Scan::create([
Â  Â  Â  Â  Â  Â  'registration_id' => $registration->id,
Â  Â  Â  Â  Â  Â  'scanned_by' => Auth::id(),
Â  Â  Â  Â  Â  Â  'scanned_time' => now(),
Â  Â  Â  Â  Â  Â  'badge_printed_status_id' => $badgeQueued->id,
Â  Â  Â  Â  ]);

Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  // If already printed â†’ mark as reprinted
Â  Â  Â  Â  Â  Â  if ($registration->badge_printed_status_id == $badgePrinted->id) {
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgeReprinted->id]);
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgeQueued->id]);
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgePrinting->id]);

Â  Â  Â  Â  Â  Â  Â  Â  // ðŸš€ Simulate print here
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgePrinted->id]);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Log::info('Scan + badge print complete', [
Â  Â  Â  Â  Â  Â  Â  Â  'ticket_number' => $ticketNumber,
Â  Â  Â  Â  Â  Â  Â  Â  'user_id' => Auth::id()
Â  Â  Â  Â  Â  Â  ]);

Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'message' => 'Scanned â†’ Badge printed',
Â  Â  Â  Â  Â  Â  Â  Â  'scan' => $scan,
Â  Â  Â  Â  Â  Â  Â  Â  'registration' => $registration->fresh(),
Â  Â  Â  Â  Â  Â  ], 200);

Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  if ($badgeFailed) {
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['badge_printed_status_id' => $badgeFailed->id]);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Log::error('Badge printing failed after scan', [
Â  Â  Â  Â  Â  Â  Â  Â  'ticket_number' => $ticketNumber,
Â  Â  Â  Â  Â  Â  Â  Â  'error' => $e->getMessage()
Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Failed to print badge after scan'], 500);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * Unified: Scan QR + Auto print Ticket
Â  Â  Â */
Â  Â  public function scanAndPrintTicket($ticketNumber): JsonResponse
Â  Â  {
Â  Â  Â  Â  $registration = Registration::where('ticket_number', $ticketNumber)->firstOrFail();

Â  Â  Â  Â  $ticketQueued Â  = PrintStatus::where('type', 'ticket')->where('name', 'queued')->first();
Â  Â  Â  Â  $ticketPrinting = PrintStatus::where('type', 'ticket')->where('name', 'printing')->first();
Â  Â  Â  Â  $ticketPrinted Â = PrintStatus::where('type', 'ticket')->where('name', 'printed')->first();
Â  Â  Â  Â  $ticketReprinted= PrintStatus::where('type', 'ticket')->where('name', 'reprinted')->first();
Â  Â  Â  Â  $ticketFailed Â  = PrintStatus::where('type', 'ticket')->where('name', 'failed')->first();

Â  Â  Â  Â  if (!$ticketQueued || !$ticketPrinting || !$ticketPrinted) {
Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Ticket print statuses not configured'], 400);
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Create scan log
Â  Â  Â  Â  $scan = Scan::create([
Â  Â  Â  Â  Â  Â  'registration_id' => $registration->id,
Â  Â  Â  Â  Â  Â  'scanned_by' => Auth::id(),
Â  Â  Â  Â  Â  Â  'scanned_time' => now(),
Â  Â  Â  Â  Â  Â  'ticket_printed_status_id' => $ticketQueued->id,
Â  Â  Â  Â  ]);

Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  // If already printed â†’ mark as reprinted
Â  Â  Â  Â  Â  Â  if ($registration->ticket_printed_status_id == $ticketPrinted->id) {
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketReprinted->id]);
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketQueued->id]);
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketPrinting->id]);

Â  Â  Â  Â  Â  Â  Â  Â  // ðŸš€ Simulate print here
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketPrinted->id]);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Log::info('Scan + ticket print complete', [
Â  Â  Â  Â  Â  Â  Â  Â  'ticket_number' => $ticketNumber,
Â  Â  Â  Â  Â  Â  Â  Â  'user_id' => Auth::id()
Â  Â  Â  Â  Â  Â  ]);

Â  Â  Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  Â  Â  'message' => 'Scanned â†’ Ticket printed',
Â  Â  Â  Â  Â  Â  Â  Â  'scan' => $scan,
Â  Â  Â  Â  Â  Â  Â  Â  'registration' => $registration->fresh(),
Â  Â  Â  Â  Â  Â  ], 200);

Â  Â  Â  Â  } catch (\Exception $e) {
Â  Â  Â  Â  Â  Â  if ($ticketFailed) {
Â  Â  Â  Â  Â  Â  Â  Â  $registration->update(['ticket_printed_status_id' => $ticketFailed->id]);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Log::error('Ticket printing failed after scan', [
Â  Â  Â  Â  Â  Â  Â  Â  'ticket_number' => $ticketNumber,
Â  Â  Â  Â  Â  Â  Â  Â  'error' => $e->getMessage()
Â  Â  Â  Â  Â  Â  ]);
Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Failed to print ticket after scan'], 500);
Â  Â  Â  Â  }
Â  Â  }
} 

<?php

namespace App\Http\Controllers;

use App\Models\ServerMode;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Gate;

class ServerModeController extends Controller
{
Â  Â  /**
Â  Â  Â * Get the current (latest) server mode.
Â  Â  Â * This is what the entire application will check against.
Â  Â  Â */
Â  Â  public function getCurrentMode(): JsonResponse
Â  Â  {
Â  Â  Â  Â  $currentMode = ServerMode::latest()->with('activatedBy:id,name')->first();

Â  Â  Â  Â  if (!$currentMode) {
Â  Â  Â  Â  Â  Â  return response()->json(['error' => 'Server mode is not configured.'], 404);
Â  Â  Â  Â  }

Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  'message' => 'Current server mode retrieved.',
Â  Â  Â  Â  Â  Â  'current_mode' => $currentMode,
Â  Â  Â  Â  ]);
Â  Â  }

Â  Â  /**
Â  Â  Â * Set a new server mode. This creates a new record, effectively
Â  Â  Â * making it the latest and current mode.
Â  Â  Â * Restricted to Superadmins only.
Â  Â  Â */
Â  Â  public function setMode(Request $request): JsonResponse
Â  Â  {
Â  Â  Â  Â  // Use the 'superadmin-only' Gate for authorization
Â  Â  Â  Â  if (!Gate::allows('superadmin-only')) {
Â  Â  Â  Â  Â  Â  abort(403, 'This action is unauthorized.');
Â  Â  Â  Â  }

Â  Â  Â  Â  $validated = $request->validate([
Â  Â  Â  Â  Â  Â  'mode' => 'required|string|in:onsite,online,both',
Â  Â  Â  Â  ]);

Â  Â  Â  Â  // Create a new mode entry, which becomes the current active mode
Â  Â  Â  Â  $newMode = ServerMode::create([
Â  Â  Â  Â  Â  Â  'mode' => $validated['mode'],
Â  Â  Â  Â  Â  Â  'activated_by' => Auth::id(),
Â  Â  Â  Â  ]);

Â  Â  Â  Â  return response()->json([
Â  Â  Â  Â  Â  Â  'message' => 'Server mode successfully updated.',
Â  Â  Â  Â  Â  Â  'new_mode' => $newMode->load('activatedBy:id,name'),
Â  Â  Â  Â  ], 201);
Â  Â  }

Â  Â  /**
Â  Â  Â * Get the history of all server mode changes, paginated.
Â  Â  Â * Useful for an audit log in the admin panel.
Â  Â  Â */
Â  Â  public function getHistory(): JsonResponse
Â  Â  {
Â  Â  Â  Â  $history = ServerMode::latest()
Â  Â  Â  Â  Â  Â  ->with('activatedBy:id,name')
Â  Â  Â  Â  Â  Â  ->paginate(15); // Paginate for performance

Â  Â  Â  Â  return response()->json($history);
Â  Â  }
} 


C:\Xamp-Jap\htdocs\Online_Registration_System\backend\app\Models 
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Log extends Model
{
Â  Â  use HasFactory;

Â  Â  protected $fillable = [
Â  Â  Â  Â  'user_id', 'action', 'target_type', 'target_id', 
Â  Â  Â  Â  'ip_address', 'description' 
Â  Â  ];

Â  Â  // Relationships
Â  Â  public function user()
Â  Â  {
Â  Â  Â  Â  return $this->belongsTo(User::class);
Â  Â  }
} 

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class PrintStatus extends Model
{
Â  Â  use HasFactory;

Â  Â  protected $fillable =[
Â  Â  Â  Â  'type', 'name', 'description', 'active',
Â  Â  ];

Â  Â  protected $casts = [
Â  Â  Â  Â  'active' => 'boolean',
Â  Â  ];

Â  Â  // relationships Â  Â 
Â  Â  
Â  Â  public function registrationsBadge()
Â  Â  {
Â  Â  Â  Â  return $this->hasMany(Registration::class, 'badge_printed_status_id');
Â  Â  }

Â  Â  public function registrationsTicket()
Â  Â  {
Â  Â  Â  Â  return $this->hasMany(Registration::class, 'ticket_printed_status_id');
Â  Â  }

Â  Â  public function scansAsBadge()
Â  Â  {
Â  Â  Â  Â  return $this->hasMany(Scan::class, 'badge_printed_status_id');
Â  Â  }

Â  Â  public function scansAsTicket()
Â  Â  {
Â  Â  Â  Â  return $this->hasMany(Scan::class, 'ticket_printed_status_id');
Â  Â  }

} 

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Support\Facades\Crypt;

class Registration extends Model
{
Â  Â  use HasFactory;

Â  Â  protected $fillable = [
Â  Â  Â  Â  'first_name', 'last_name', 'email', 'phone', 'address',
Â  Â  Â  Â  'registration_type', 'server_mode', 'qr_code_path',
Â  Â  Â  Â  'ticket_number', 'confirmed_at', 'email_hash',
Â  Â  ];

Â  Â  protected $guarded = [
Â  Â  Â  Â  'badge_printed_status_id', 'ticket_printed_status_id',
Â  Â  Â  Â  'confirmed', 'confirmed_by', 'registered_by',
Â  Â  ];

Â  Â  protected $casts = [
Â  Â  Â  Â  'confirmed' Â  Â => 'boolean',
Â  Â  Â  Â  'confirmed_at' => 'datetime',
Â  Â  Â  Â  'created_at' Â  => 'datetime', Â 
Â  Â  Â  Â  'updated_at' Â  => 'datetime', Â 
Â  Â  ];

Â  Â  /* ---------------------------
Â  Â  Â | Â Encrypt / Decrypt Fields
Â  Â  Â |----------------------------*/
Â  Â  public function setFirstNameAttribute($value)
Â  Â  {
Â  Â  Â  Â  $this->attributes['first_name'] = Crypt::encryptString($value);
Â  Â  }
Â  Â  public function getFirstNameAttribute($value)
Â  Â  {
Â  Â  Â  Â  return $value ? Crypt::decryptString($value) : null;
Â  Â  }

Â  Â  public function setLastNameAttribute($value)
Â  Â  {
Â  Â  Â  Â  $this->attributes['last_name'] = Crypt::encryptString($value);
Â  Â  }
Â  Â  public function getLastNameAttribute($value)
Â  Â  {
Â  Â  Â  Â  return $value ? Crypt::decryptString($value) : null;
Â  Â  }

Â  Â  public function setEmailAttribute($value)
Â  Â  {
Â  Â  Â  Â  $this->attributes['email'] = Crypt::encryptString($value);
Â  Â  }
Â  Â  public function getEmailAttribute($value)
Â  Â  {
Â  Â  Â  Â  return $value ? Crypt::decryptString($value) : null;
Â  Â  }

Â  Â  public function setPhoneAttribute($value)
Â  Â  {
Â  Â  Â  Â  $this->attributes['phone'] = $value ? Crypt::encryptString($value) : null;
Â  Â  }
Â  Â  public function getPhoneAttribute($value)
Â  Â  {
Â  Â  Â  Â  return $value ? Crypt::decryptString($value) : null;
Â  Â  }

Â  Â  public function setAddressAttribute($value)
Â  Â  {
Â  Â  Â  Â  $this->attributes['address'] = $value ? Crypt::encryptString($value) : null;
Â  Â  }
Â  Â  public function getAddressAttribute($value)
Â  Â  {
Â  Â  Â  Â  return $value ? Crypt::decryptString($value) : null;
Â  Â  }

Â  Â  /* ---------------------------
Â  Â  Â | Â Relationships
Â  Â  Â |----------------------------*/
Â  Â  public function confirmedBy()
Â  Â  {
Â  Â  Â  Â  return $this->belongsTo(User::class, 'confirmed_by');
Â  Â  }

Â  Â  public function registeredBy()
Â  Â  {
Â  Â  Â  Â  return $this->belongsTo(User::class, 'registered_by');
Â  Â  }

Â  Â  public function scans()
Â  Â  {
Â  Â  Â  Â  return $this->hasMany(Scan::class);
Â  Â  }

Â  Â  public function badgeStatus()
Â  Â  {
Â  Â  Â  Â  return $this->belongsTo(PrintStatus::class, 'badge_printed_status_id');
Â  Â  }

Â  Â  public function ticketStatus()
Â  Â  {
Â  Â  Â  Â  return $this->belongsTo(PrintStatus::class, 'ticket_printed_status_id');
Â  Â  }
} 

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Role extends Model
{
Â  Â  use HasFactory;

Â  Â  protected $fillable = [
Â  Â  Â  Â  'name', 'permissions', 'description',
Â  Â  ];

Â  Â  protected $casts = [
Â  Â  Â  Â  'permissions' => 'array', Â // JSON to array
Â  Â  ];

Â  Â  // Relationship
Â  Â  public function users()
Â  Â  {
Â  Â  Â  Â  return $this->hasMany(User::class);
Â  Â  }
} 

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Scan extends Model
{
Â  Â  use HasFactory;

Â  Â  protected $fillable =[
Â  Â  Â  Â  'registration_id', 'scanned_by', 'scanned_time', 'badge_printed_status_id',
Â  Â  Â  Â  'ticket_printed_status_id'
Â  Â  ];

Â  Â  protected $casts = [
Â  Â  Â  Â  'scanned_time' => 'datetime',
Â  Â  Â  Â  'created_at' Â => 'datetime',
Â  Â  Â  Â  'updated_at' Â => 'datetime',
Â  Â  ];

Â  Â  //relationships

Â  Â  public function registration()
Â  Â  {
Â  Â  Â  Â  return $this->belongsTo(Registration::class);
Â  Â  }

Â  Â  public function scannedBy()
Â  Â  {
Â  Â  Â  Â  return $this->belongsTo(User::class, 'scanned_by');
Â  Â  }

Â  Â  public function badgeStatus()
Â  Â  {
Â  Â  Â  Â  return $this->belongsTo(PrintStatus::class, 'badge_printed_status_id');
Â  Â  }

Â  Â  public function ticketStatus()
Â  Â  {
Â  Â  Â  Â  return $this->belongsTo(PrintStatus::class, 'ticket_printed_status_id');
Â  Â  }
} 

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class ServerMode extends Model
{
Â  Â  use HasFactory;

Â  Â  protected $fillable = ['mode', 'activated_by'];

Â  Â  protected $casts = [
Â  Â  Â  Â  'created_at' => 'datetime',
Â  Â  Â  Â  'updated_at' => 'datetime',
Â  Â  ];

Â  Â  // relationship
Â  Â  public function activatedBy()
Â  Â  {
Â  Â  Â  Â  return $this->belongsTo(User::class, 'activated_by');
Â  Â  }
} 

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
use Illuminate\Support\Facades\Crypt;

class User extends Authenticatable
{
Â  Â  /** @use HasFactory<\Database\Factories\UserFactory> */
Â  Â  use HasApiTokens, HasFactory, Notifiable;

Â  Â  /**
Â  Â  Â * Always eager load these relationships.
Â  Â  Â *
Â  Â  Â * This ensures Auth::user() and Sanctum tokens
Â  Â  Â * always include the role without lazy-loading issues.
Â  Â  Â */
Â  Â  protected $with = ['role'];

Â  Â  /**
Â  Â  Â * The attributes that are mass assignable.
Â  Â  Â *
Â  Â  Â * @var list<string>
Â  Â  Â */
Â  Â  protected $fillable = [
Â  Â  Â  Â  'name',
Â  Â  Â  Â  'email',
Â  Â  Â  Â  'phone',
Â  Â  Â  Â  'password',
Â  Â  ];

Â  Â  protected $guarded = [
Â  Â  Â  Â  'role_id',
Â  Â  Â  Â  'status',
Â  Â  Â  Â  'created_by',
Â  Â  ];

Â  Â  /**
Â  Â  Â * The attributes that should be hidden for serialization.
Â  Â  Â *
Â  Â  Â * @var list<string>
Â  Â  Â */
Â  Â  protected $hidden = [
Â  Â  Â  Â  'password',
Â  Â  Â  Â  'remember_token',
Â  Â  ];

Â  Â  /**
Â  Â  Â * Get the attributes that should be cast.
Â  Â  Â *
Â  Â  Â * @return array<string, string>
Â  Â  Â */
Â  Â  protected function casts(): array
Â  Â  {
Â  Â  Â  Â  return [
Â  Â  Â  Â  Â  Â  'email_verified_at' => 'datetime',
Â  Â  Â  Â  Â  Â  'password' => 'hashed',
Â  Â  Â  Â  ];
Â  Â  }

Â  Â  // Added phone encryption
Â  Â  public function setPhoneAttribute($value)
Â  Â  {
Â  Â  Â  Â  $this->attributes['phone'] = $value ? Crypt::encryptString($value) : null;
Â  Â  }

Â  Â  public function getPhoneAttribute($value)
Â  Â  {
Â  Â  Â  Â  return $value ? Crypt::decryptString($value) : null;
Â  Â  }
Â  Â  // ðŸ”¹ Relationships
Â  Â  public function role()
Â  Â  {
Â  Â  Â  Â  return $this->belongsTo(Role::class);
Â  Â  }

Â  Â  public function registrations()
Â  Â  {
Â  Â  Â  Â  return $this->hasMany(Registration::class, 'registered_by');
Â  Â  }

Â  Â  public function scans()
Â  Â  {
Â  Â  Â  Â  return $this->hasMany(Scan::class, 'scanned_by');
Â  Â  }

Â  Â  public function logs()
Â  Â  {
Â  Â  Â  Â  return $this->hasMany(Log::class);
Â  Â  }
} 


C:\Xamp-Jap\htdocs\Online_Registration_System\backend\database\migrations

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
Â  Â  /**
Â  Â  Â * Run the migrations.
Â  Â  Â */
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::create('roles', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->id(); // Primary key

Â  Â  Â  Â  Â  Â  // Role Details
Â  Â  Â  Â  Â  Â  $table->string('name', 50)->unique()->comment('Role name: Super Admin, Admin, User'); // Added unique constraint
Â  Â  Â  Â  Â  Â  $table->json('permissions')->nullable()->comment('Storing Permission in JSON Format');
Â  Â  Â  Â  Â  Â  $table->text('description')->nullable()->comment('Description of the role');
Â  Â  Â  Â  Â  Â  $table->timestamps(); // Create_at, Updated_at timestamps
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  $table->index('created_at');
Â  Â  Â  Â  });
Â  Â  }

Â  Â  /**
Â  Â  Â * Reverse the migrations.
Â  Â  Â */
Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::dropIfExists('roles');
Â  Â  }
}; 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
Â  Â  /**
Â  Â  Â * Run the migrations.
Â  Â  Â */
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::create('users', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->id();
Â  Â  Â  Â  Â  Â  // Link to roles table
Â  Â  Â  Â  Â  Â  $table->foreignId('role_id')->constrained('roles')->cascadeOnUpdate()->restrictOnDelete();
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // User basic information
Â  Â  Â  Â  Â  Â  $table->string('name'); // Full name of the user
Â  Â  Â  Â  Â  Â  $table->string('email')->unique()->index(); // Added index for search performance
Â  Â  Â  Â  Â  Â  $table->timestamp('email_verified_at')->nullable(); // Timestamp when the email was verified
Â  Â  Â  Â  Â  Â  $table->string('password', 255)->nullable(); // Keep nullable if some users (attendees) donâ€™t need login 
Â  Â  Â  Â  Â  Â  $table->string('phone', 1000)->nullable(); // Increased length for encryption

Â  Â  Â  Â  Â  Â  // User account status
Â  Â  Â  Â  Â  Â  $table->enum('status', ['active', 'inactive'])->default('active')->index(); 

Â  Â  Â  Â  Â  Â  // Remember token for password reset
Â  Â  Â  Â  Â  Â  $table->rememberToken();

Â  Â  Â  Â  Â  Â  // Track who created this user (self-referencing FK)
Â  Â  Â  Â  Â  Â  $table->foreignId('created_by')->nullable()->constrained('users')->nullOnDelete();

Â  Â  Â  Â  Â  Â  $table->timestamps();
Â  Â  Â  Â  });

Â  Â  Â  Â  Schema::create('password_reset_tokens', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->string('email', 150)->primary();
Â  Â  Â  Â  Â  Â  $table->string('token');
Â  Â  Â  Â  Â  Â  $table->timestamp('created_at')->nullable();
Â  Â  Â  Â  });

Â  Â  Â  Â  Schema::create('sessions', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->string('id')->primary();
Â  Â  Â  Â  Â  Â  $table->foreignId('user_id')->nullable()->index();
Â  Â  Â  Â  Â  Â  $table->string('ip_address', 45)->nullable();
Â  Â  Â  Â  Â  Â  $table->text('user_agent')->nullable();
Â  Â  Â  Â  Â  Â  $table->longText('payload');
Â  Â  Â  Â  Â  Â  $table->integer('last_activity')->index();
Â  Â  Â  Â  });
Â  Â  }

Â  Â  /**
Â  Â  Â * Reverse the migrations.
Â  Â  Â */
Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::dropIfExists('users');
Â  Â  Â  Â  Schema::dropIfExists('password_reset_tokens');
Â  Â  Â  Â  Schema::dropIfExists('sessions');
Â  Â  }
}; 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
Â  Â  /**
Â  Â  Â * Run the migrations.
Â  Â  Â */
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::create('cache', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->string('key')->primary();
Â  Â  Â  Â  Â  Â  $table->mediumText('value');
Â  Â  Â  Â  Â  Â  $table->integer('expiration');
Â  Â  Â  Â  });

Â  Â  Â  Â  Schema::create('cache_locks', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->string('key')->primary();
Â  Â  Â  Â  Â  Â  $table->string('owner');
Â  Â  Â  Â  Â  Â  $table->integer('expiration');
Â  Â  Â  Â  });
Â  Â  }

Â  Â  /**
Â  Â  Â * Reverse the migrations.
Â  Â  Â */
Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::dropIfExists('cache');
Â  Â  Â  Â  Schema::dropIfExists('cache_locks');
Â  Â  }
}; 


<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
Â  Â  /**
Â  Â  Â * Run the migrations.
Â  Â  Â */
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::create('jobs', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->id();
Â  Â  Â  Â  Â  Â  $table->string('queue')->index();
Â  Â  Â  Â  Â  Â  $table->longText('payload');
Â  Â  Â  Â  Â  Â  $table->unsignedTinyInteger('attempts');
Â  Â  Â  Â  Â  Â  $table->unsignedInteger('reserved_at')->nullable();
Â  Â  Â  Â  Â  Â  $table->unsignedInteger('available_at');
Â  Â  Â  Â  Â  Â  $table->unsignedInteger('created_at');
Â  Â  Â  Â  });

Â  Â  Â  Â  Schema::create('job_batches', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->string('id')->primary();
Â  Â  Â  Â  Â  Â  $table->string('name');
Â  Â  Â  Â  Â  Â  $table->integer('total_jobs');
Â  Â  Â  Â  Â  Â  $table->integer('pending_jobs');
Â  Â  Â  Â  Â  Â  $table->integer('failed_jobs');
Â  Â  Â  Â  Â  Â  $table->longText('failed_job_ids');
Â  Â  Â  Â  Â  Â  $table->mediumText('options')->nullable();
Â  Â  Â  Â  Â  Â  $table->integer('cancelled_at')->nullable();
Â  Â  Â  Â  Â  Â  $table->integer('created_at');
Â  Â  Â  Â  Â  Â  $table->integer('finished_at')->nullable();
Â  Â  Â  Â  });

Â  Â  Â  Â  Schema::create('failed_jobs', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->id();
Â  Â  Â  Â  Â  Â  $table->string('uuid')->unique();
Â  Â  Â  Â  Â  Â  $table->text('connection');
Â  Â  Â  Â  Â  Â  $table->text('queue');
Â  Â  Â  Â  Â  Â  $table->longText('payload');
Â  Â  Â  Â  Â  Â  $table->longText('exception');
Â  Â  Â  Â  Â  Â  $table->timestamp('failed_at')->useCurrent();
Â  Â  Â  Â  });
Â  Â  }

Â  Â  /**
Â  Â  Â * Reverse the migrations.
Â  Â  Â */
Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::dropIfExists('jobs');
Â  Â  Â  Â  Schema::dropIfExists('job_batches');
Â  Â  Â  Â  Schema::dropIfExists('failed_jobs');
Â  Â  }
}; 


<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
Â  Â  /**
Â  Â  Â * Run the migrations.
Â  Â  Â */
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::create('print_statuses', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->id(); // Primary Key

Â  Â  Â  Â  Â  Â  // Badge or Ticket status
Â  Â  Â  Â  Â  Â  $table->enum('type', ['badge', 'ticket'])
Â  Â  Â  Â  Â  Â  Â  Â  Â  ->comment('Defines whether this status applies to badges or tickets');

Â  Â  Â  Â  Â  Â  // Status name (unique within type)
Â  Â  Â  Â  Â  Â  $table->string('name', 50)
Â  Â  Â  Â  Â  Â  Â  Â  Â  ->comment('E.g., not_printed, printed, reprinted');

Â  Â  Â  Â  Â  Â  $table->text('description')->nullable()
Â  Â  Â  Â  Â  Â  Â  Â  Â  ->comment('Optional description of the status meaning');

Â  Â  Â  Â  Â  Â  // Active flag
Â  Â  Â  Â  Â  Â  $table->tinyInteger('active')->default(1)
Â  Â  Â  Â  Â  Â  Â  Â  Â ->comment('1 = Active, 0 = Disabled'); Â // Added comment

Â  Â  Â  Â  Â  Â  // Timestamps
Â  Â  Â  Â  Â  Â  $table->timestamps();

Â  Â  Â  Â  Â  Â  // Constraints & Indexes
Â  Â  Â  Â  Â  Â  $table->unique(['type', 'name']); // Prevent duplicate status names for same type
Â  Â  Â  Â  Â  Â  $table->index('type'); // Quick lookups by type
Â  Â  Â  Â  });
Â  Â  }

Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::dropIfExists('print_statuses');
Â  Â  }
}; 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::create('registrations', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->id();

Â  Â  Â  Â  Â  Â  // Encrypted personal info
Â  Â  Â  Â  Â  Â  $table->text('first_name');
Â  Â  Â  Â  Â  Â  $table->text('last_name');
Â  Â  Â  Â  Â  Â  $table->text('email');
Â  Â  Â  Â  Â  Â  $table->text('phone')->nullable();
Â  Â  Â  Â  Â  Â  $table->text('address')->nullable();

Â  Â  Â  Â  Â  Â  $table->enum('registration_type', ['onsite','online','pre-registered'])->index();

Â  Â  Â  Â  Â  Â  // Ticket / QR
Â  Â  Â  Â  Â  Â  $table->string('ticket_number', 100)->unique()->nullable();
Â  Â  Â  Â  Â  Â  $table->string('qr_code_path', 255)->nullable();

Â  Â  Â  Â  Â  Â  $table->enum('server_mode', ['onsite','online','both'])->default('onsite')->index();

Â  Â  Â  Â  Â  Â  // Print statuses
Â  Â  Â  Â  Â  Â  $table->foreignId('badge_printed_status_id')->nullable()
Â  Â  Â  Â  Â  Â  Â  Â  Â  ->constrained('print_statuses')->nullOnDelete();
Â  Â  Â  Â  Â  Â  $table->foreignId('ticket_printed_status_id')->nullable()
Â  Â  Â  Â  Â  Â  Â  Â  Â  ->constrained('print_statuses')->nullOnDelete();

Â  Â  Â  Â  Â  Â  // Confirmation
Â  Â  Â  Â  Â  Â  $table->boolean('confirmed')->default(false);
Â  Â  Â  Â  Â  Â  $table->foreignId('confirmed_by')->nullable()
Â  Â  Â  Â  Â  Â  Â  Â  Â  ->constrained('users')->nullOnDelete();
Â  Â  Â  Â  Â  Â  $table->timestamp('confirmed_at')->nullable();

Â  Â  Â  Â  Â  Â  // Who registered
Â  Â  Â  Â  Â  Â  $table->foreignId('registered_by')->nullable()
Â  Â  Â  Â  Â  Â  Â  Â  Â  ->constrained('users')->nullOnDelete();

Â  Â  Â  Â  Â  Â  $table->timestamps();
Â  Â  Â  Â  });
Â  Â  }

Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::dropIfExists('registrations');
Â  Â  }
}; 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
Â  Â  /**
Â  Â  Â * Run the migrations.
Â  Â  Â */
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::create('logs', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->id(); // Primary key
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // actor of the action
Â  Â  Â  Â  Â  Â  $table->foreignId('user_id')->nullable()->constrained('users')->nullOnDelete(); // User who performed the action
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // action metadata
Â  Â  Â  Â  Â  Â  $table->string('action', 255); // short action name 
Â  Â  Â  Â  Â  Â  $table->string('target_type', 50)->nullable(); // Type of the target entity (e.g., 'registration', 'user', etc.)
Â  Â  Â  Â  Â  Â  $table->unsignedBigInteger('target_id')->nullable(); // Related entity ID

Â  Â  Â  Â  Â  Â  // IP address 
Â  Â  Â  Â  Â  Â  $table->string('ip_address', 45)->nullable(); // IP address of the user performing the action
Â  Â  Â  Â  Â  Â  $table->text('description')->nullable(); // Detailed description of the action
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  $table->timestamps();

Â  Â  Â  Â  Â  Â  // Indexes for performance
Â  Â  Â  Â  Â  Â  $table->index('action');
Â  Â  Â  Â  Â  Â  $table->index('created_at');
Â  Â  Â  Â  Â  Â  $table->index('user_id'); Â // Added
Â  Â  Â  Â  Â  Â  $table->index(['target_type', 'target_id']); Â // Added composite index
Â  Â  Â  Â  });
Â  Â  }

Â  Â  /**
Â  Â  Â * Reverse the migrations.
Â  Â  Â */
Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::dropIfExists('logs');
Â  Â  }
}; 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
Â  Â  /**
Â  Â  Â * Run the migrations.
Â  Â  Â */
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::create('error_logs', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->id();

Â  Â  Â  Â  Â  Â  // user who experienced the error (nullable)
Â  Â  Â  Â  Â  Â  $table->foreignId('user_id')->nullable()->constrained('users')->nullOnDelete();

Â  Â  Â  Â  Â  Â  // Error details
Â  Â  Â  Â  Â  Â  $table->string('error_code', 50)->nullable(); // Optional Error Code 
Â  Â  Â  Â  Â  Â  $table->text('error_message'); // Detailed error message
Â  Â  Â  Â  Â  Â  $table->longText('stack_trace')->nullable(); // Stack trace for debugging (optional)

Â  Â  Â  Â  Â  Â  $table->timestamps();

Â  Â  Â  Â  Â  Â  $table->index('created_at'); // Index for performance
Â  Â  Â  Â  }); 
Â  Â  }

Â  Â  /**
Â  Â  Â * Reverse the migrations.
Â  Â  Â */
Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::dropIfExists('error_logs');
Â  Â  }
}; 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
Â  Â  /**
Â  Â  Â * Run the migrations.
Â  Â  Â */
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::create('server_modes', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->id();

Â  Â  Â  Â  Â  Â  // Mode set by Super Admin
Â  Â  Â  Â  Â  Â  $table->enum('mode', ['onsite', 'online', 'both'])->index(); Â // Added index

Â  Â  Â  Â  Â  Â  // who activated this mode
Â  Â  Â  Â  Â  Â  $table->foreignId('activated_by')
Â  Â  Â  Â  Â  Â  Â  Â  Â  ->nullable()
Â  Â  Â  Â  Â  Â  Â  Â  Â  ->constrained('users')
Â  Â  Â  Â  Â  Â  Â  Â  Â  ->cascadeOnUpdate()
Â  Â  Â  Â  Â  Â  Â  Â  Â  ->nullOnDelete();
Â  Â  Â  Â  Â  Â  $table->timestamps();

Â  Â  Â  Â  Â  Â  // Indexes for Reporting
Â  Â  Â  Â  Â  Â  $table->index('created_at');
Â  Â  Â  Â  });
Â  Â  }

Â  Â  /**
Â  Â  Â * Reverse the migrations.
Â  Â  Â */
Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::dropIfExists('server_modes');
Â  Â  }
}; 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
Â  Â  /**
Â  Â  Â * Run the migrations.
Â  Â  Â */
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::create('scans', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->id();
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  // Registration being Scanned
Â  Â  Â  Â  Â  Â  $table->foreignId('registration_id')->constrained('registrations')->cascadeOnDelete();

Â  Â  Â  Â  Â  Â  // Who scanned (nullable, e.g. Auto scan)
Â  Â  Â  Â  Â  Â  $table->foreignId('scanned_by')->nullable()->constrained('users')->nullOnDelete();

Â  Â  Â  Â  Â  Â  // When it was scanned
Â  Â  Â  Â  Â  Â  $table->timestamp('scanned_time')->useCurrent();

Â  Â  Â  Â  Â  Â  // Badge / Ticket printing status (configurable via print_statuses)
Â  Â  Â  Â  Â  Â  $table->foreignId('badge_printed_status_id')->nullable()->constrained('print_statuses')->nullOnDelete();
Â  Â  Â  Â  Â  Â  $table->foreignId('ticket_printed_status_id')->nullable()->constrained('print_statuses')->nullOnDelete();

Â  Â  Â  Â  Â  Â  $table->timestamps();

Â  Â  Â  Â  Â  Â  // Indexes for performance
Â  Â  Â  Â  Â  Â  $table->index('scanned_time');
Â  Â  Â  Â  Â  Â  $table->index(['registration_id', 'badge_printed_status_id']);
Â  Â  Â  Â  Â  Â  $table->index(['registration_id', 'ticket_printed_status_id']);
Â  Â  Â  Â  Â  Â  $table->index('scanned_by'); Â // Added
Â  Â  Â  Â  });
Â  Â  }

Â  Â  /**
Â  Â  Â * Reverse the migrations.
Â  Â  Â */
Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::dropIfExists('scans');
Â  Â  }
}; 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
Â  Â  /**
Â  Â  Â * Run the migrations.
Â  Â  Â */
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::create('personal_access_tokens', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  $table->id();
Â  Â  Â  Â  Â  Â  $table->morphs('tokenable');
Â  Â  Â  Â  Â  Â  $table->text('name');
Â  Â  Â  Â  Â  Â  $table->string('token', 64)->unique();
Â  Â  Â  Â  Â  Â  $table->text('abilities')->nullable();
Â  Â  Â  Â  Â  Â  $table->timestamp('last_used_at')->nullable();
Â  Â  Â  Â  Â  Â  $table->timestamp('expires_at')->nullable()->index();
Â  Â  Â  Â  Â  Â  $table->timestamps();
Â  Â  Â  Â  });
Â  Â  }

Â  Â  /**
Â  Â  Â * Reverse the migrations.
Â  Â  Â */
Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::dropIfExists('personal_access_tokens');
Â  Â  }
}; 

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
Â  Â  public function up(): void
Â  Â  {
Â  Â  Â  Â  Schema::table('registrations', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  // This column will store a hash of the email for fast, unique lookups.
Â  Â  Â  Â  Â  Â  // It should not be nullable as our application logic always provides it.
Â  Â  Â  Â  Â  Â  $table->string('email_hash')->after('email')->unique()->nullable(false);
Â  Â  Â  Â  });
Â  Â  }

Â  Â  public function down(): void
Â  Â  {
Â  Â  Â  Â  Schema::table('registrations', function (Blueprint $table) {
Â  Â  Â  Â  Â  Â  // Ensure we check if the column exists before trying to drop it.
Â  Â  Â  Â  Â  Â  if (Schema::hasColumn('registrations', 'email_hash')) {
Â  Â  Â  Â  Â  Â  Â  Â  $table->dropColumn('email_hash');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  }
};


save data first as I command no Configurations needed, Just save all the data until I say 'develop' 


